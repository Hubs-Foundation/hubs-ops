AWSTemplateFormatVersion: '2010-09-09'
Description: |
  Hubs Cloud: Private Social VR in your web browser. Hosted instance of Hubs and Spoke by Mozilla. Full documentation: https://github.com/mozilla/hubs-cloud

Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: Account Configuration
        Parameters:
          - AdminEmailAddress
      - Label:
          default: Domain Configuration
        Parameters:
          - DomainName
          - IsDomainOnRoute53
          - InternalZone
          - ShortlinkZone
      - Label:
          default: Email Configuration
        Parameters:
          - EmailZone
          - EmailSubdomain
      - Label:
          default: Server Configuration
        Parameters:
          - KeyPair
          - AppInstanceCount
          - StreamInstanceCount
          - AppInstanceType
          - StreamInstanceType
          - MaintenenceWindow
      - Label:
          default: Cost Management
        Parameters:
          - DatabaseMonthlyBudget
          - MaxStorage
      - Label:
          default: Stack Status
        Parameters:
          - StackOffline
          - StackOfflineRedirectUrl
      - Label:
          default: Custom SSL Certificates
        Parameters:
          - UnmanagedDomainCertArn
      - Label:
          default: Database Configuration
        Parameters:
          - AutoPauseDb
          - DbBackupRetentionPeriod
      - Label:
          default: Restore from Backup
        Parameters:
          - RestoreStackName
          - RestoreStackRegion
          - RestoreDbSnapshotIdentifier
          - RestoreAppDbSecretArn
          - RestoreBackupVaultName
          - RestoreRecoveryPointArn
      - Label:
          default: Advanced - Leave these alone unless you know what you're doing!
        Parameters:
          - DbMaxCapacity
          - LoadBalancingMethod
          - NewCMKForDiskEncryption
          - ChannelType
          - SubnetAZs
          - ClassB
          - AppPlacementGroupStrategy
          - DbPreferredBackupWindow
          - DbPreferredMaintenanceWindow
    ParameterLabels:
      DomainName:
        default: Domain Name
      IsDomainOnRoute53:
        default: Is your domain set up on Route 53?
      ShortlinkZone:
        default: Short link domain name
      InternalZone:
        default: Internal domain name
      EmailZone:
        default: Outgoing Email Domain
      EmailSubdomain:
        default: Outgoing Email Subdomain Prefix
      AdminEmailAddress:
        default: Administrator Email Address
      UnmanagedDomainCertArn:
        default: Unmanaged Domain SSL Certificate ARN
      AppInstanceCount:
        default: Number of app servers
      AppInstanceType:
        default: App server EC2 instance type
      StreamInstanceCount:
        default: Number of voice/videos streaming servers
      StreamInstanceType:
        default: Voice/video streaming server EC2 instance type
      ClassB:
        default: Class B IP Block
      NewCMKForDiskEncryption:
        default: Create a dedicated CMK for database and backup encryption?
      AppPlacementGroupStrategy:
        default: App server placement group strategy
      DbBackupRetentionPeriod:
        default: "Database backup retention period (in days)"
      DbMaxCapacity:
        default: "Max database capacity (in ACUs)"
      RestoreDbSnapshotIdentifier:
        default: "Restore From Db Snapshot Identifier"
      RestoreAppDbSecretArn:
        default: "Restore From Database Secret ARN"
      RestoreStackName:
        default: "Restore From Stack Name"
      RestoreStackRegion:
        default: "Restore From Stack Region"
      RestoreBackupVaultName:
        default: "Restore From Vault Name"
      RestoreRecoveryPointArn:
        default: "Restore From Recovery Point ARN"
      MaintenenceWindow:
        default: "Scheduled maintenence window"
      ChannelType:
        default : "Package release channel"
      LoadBalancingMethod:
        default : "Load Balancing Method"
      AutoPauseDb:
        default : "Auto-Pause Database"
      SubnetAZs:
        default : "Subnet Availability Zones"
      StackOffline:
        default: "Stack Status"
      StackOfflineRedirectUrl:
        default: "Offline Redirect URL (Optional)"
      DatabaseMonthlyBudget:
        default: "Account Monthly Database Budget (US dollars, no $ and no cents)"
      MaxStorage:
        default: "Storage Limit (in GB)"
Parameters:
  DomainName:
    Type: String
    Description: Domain name Hubs Cloud will be hosted on. (eg myhubs.com or hubs.mydomain.com.) This should be a domain you already own, either on a third party provider (eg GoDaddy or Namecheap) or on AWS Route 53.
    AllowedPattern: ^((?:([a-z0-9]\.|[a-z0-9][a-z0-9\-]{0,61}[a-z0-9])\.)+)([a-z0-9]{2,63}|(?:[a-z0-9][a-z0-9\-]{0,61}[a-z0-9]))\.?$
    ConstraintDescription: Must be a valid domain name (eg myhubs.com or hubs.mycompany.com)
  IsDomainOnRoute53:
    Type: String
    Description: We recommended you use Route 53 to manage your domain. Set to Yes if your domain is set up on Route 53, and you can move onto the next item. Set to No if your domain is on a third party service such as GoDaddy or Namecheap. If you choose 'No', you'll need to set the 'Unmanaged Domain SSL Certificate ARN' configuration setting in the 'SSL Certificates' section below. Also, if you choose 'No', once your stack is created you'll need to update your DNS provider using the information in the 'Outputs' tab. See the 'Outputs' tab once the stack is created for more information on what to do next.
    AllowedValues: ["Yes - My domain is set up on Route 53", "No - My domain is not on Route 53 and I will set up my SSL certificate below in the 'SSL Certificates' section"]
  ShortlinkZone:
    Type: AWS::Route53::HostedZone::Id
    Description: You'll need a Route 53 domain name for short room permalinks, entry codes, and device linking. (eg myhubs.link) It should *not* be the same domain as the any of the Hubs Cloud domain names that you specified above. This domain will be used by visitors to share room links, and ideally should be short and easy to type since it will be typed by users on mobile devices and in VR.
    AllowedPattern: ".+"
    ConstraintDescription: You didn't specify a short link Route 53 Zone. Please choose one or create a new domain name on AWS on Route 53, ideally one short and easy to type.
  InternalZone:
    Type: AWS::Route53::HostedZone::Id
    Description: Hubs Cloud needs a domain name to use internally for server management. If your primary domain is on Route 53 and you're not using it for anything else, you can choose it here. Otherwise, you'll need to register a new domain name on Route 53 for this (for example, myhubs-internal.com). This domain name will not be seen by users.
    AllowedPattern: ".+"
    ConstraintDescription: You didn't specify an internal Route 53 Zone. Please choose one or create a new domain name on AWS on Route 53. It can be anything you want and is used internally. It will not be seen by your visitors.
  EmailZone:
    Type: AWS::Route53::HostedZone::Id
    Description: To verify email addresses, Hubs Cloud needs to be able to send email. If you do not have an existing email SMTP provider, choose a Route 53 domain you'd like to send email from. It will be set up automatically using AWS Simple Email Service. If you have an existing email provider you'd like to send email from (eg Mailchimp) or already have a verified domain in AWS Simple Email Service select the same zone you chose above for 'Internal Route 53 Zone' and you'll be able to enter the login credentials from your email provider later.
    AllowedPattern: ".+"
    ConstraintDescription: You didn't specify an Route 53 Zone to send email from. Please choose one. If you already have email set up, just choose your Internal Route 53 Zone.
  EmailSubdomain:
    Type: String
    Description: The Subdomain prefix to use for outgoing emails. For example, if your Outgoing Email Route 53 Zone is set to myhubs.com, setting this field to "mail" will send email from the domain mail.myhubs.com. If you have a third party email provider (eg Mailchimp) you can ignore this field.
    Default: mail
  AdminEmailAddress:
    Type: String
    Description: Email address for your administrator account. Individuals with access to this email address will have full administrative control of your Hubs Cloud instance. Before you can log in, you will need to verify this email address - you will get a verification email from AWS after the stack is ready. This will also be shared with LetsEncrypt for urgent SSL renewal or security updates. By deploying this stack you agree to the LetsEncrypt TOS. (https://letsencrypt.org/repository/)
    AllowedPattern: ".+"
    ConstraintDescription: "You must enter a contact email address."
  UnmanagedDomainCertArn:
    Type: String
    Description: "You can skip this if your domain is on Route 53 and you chose 'Yes' above to 'Is your domain set up on Route 53?'. Otherwise, if you chose 'No' and you are using a domain name managed by another provider like GoDaddy or Namecheap you will need to create an SSL certificate in AWS Certificate Manager before completing this form. Instructions can be found at https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-request-public.html. *Note* - make sure you create your SSL certificate in the AWS region you'd like to use for your Hubs Cloud stack. (The region can be found in the top right corner of the AWS console.) Once you've created the certificate, paste the ARN for the certificate here (eg arn:aws:acm:<region>:<account>:certificate/<id>). You can find the ARN by clicking on the certificate in the AWS Certificate Manager console."
    ConstraintDescription: You must point to an ARN in AWS Certificate Manager for your domain.
  AppInstanceCount:
    Type: Number
    Description: The number of app server(s) you'd like to run. The app servers provide all the necessary services for Hubs Cloud. You must run at least one app server. Set to zero to temporarily shut down your site.
    Default: 1
    MinValue: 0
    ConstraintDescription: You must run at least one app server.
  AppInstanceType:
    Type: String
    Description: The EC2 instance type for your app server(s). Choose a "t" instance type if you expect bursty use of the service, and the "c" or "m" types if you expect steady usage.
    Default: t2.micro
    AllowedValues:
      - t2.micro
      - t2.small
      - t3.medium
      - t3.large
      - c5.large
      - c5.xlarge
      - c5.2xlarge
      - c5.4xlarge
  StreamInstanceCount:
    Type: Number
    Description: The number of dedicated voice/video streaming server(s) you'd like to run. These servers are optional - enter a zero here if you do not want to run any streaming servers. Adding streaming servers will take network and CPU load off of your app servers. These servers will transmit voice and streaming video data between users.
    Default: 0
    MinValue: 0
  StreamInstanceType:
    Type: String
    Description: The EC2 instance type for your streaming server(s), if you've added any. This field will not be used if you entered zero for the number of streaming servers. Choose a "t" instance type if you expect bursty use of the service, and the "c" or "m" types if you expect steady usage.
    Default: t2.micro
    AllowedValues:
      - t2.micro
      - t2.small
      - t3.medium
      - t3.large
      - c5.large
      - c5.xlarge
      - c5.2xlarge
      - c5.4xlarge
  KeyPair:
    Type: AWS::EC2::KeyPair::KeyName
    Description: "SSH Keypair for server SSH access. If there no keypairs in this list, you'll need to add a SSH keypair via the EC2 console. See: https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-key-pairs.html#having-ec2-create-your-key-pair."
    AllowedPattern: ".+"
    ConstraintDescription: "You must choose an SSH keypair. To create one, see: https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-key-pairs.html#having-ec2-create-your-key-pair."
  ClassB:
    Type: String
    Description: VPC ClassB (10.XX.0.0/16) block to use for internal server IPs.
    Default: 0
  AppPlacementGroupStrategy:
    Type: String
    Description: "Placement group strategy for app servers. If you only have one app server, this setting has no effect. If you have more than one app server, choose 'cluster' to increase connectivity between servers at the cost of reliability. When using 'cluster', you will have lower latency between users but your service will go down if there is an AZ-wide outage. Choose 'spread' if you would like to ensure higher availability at the cost of latency or maximum throughput between app servers. Choose 'none' if you do not have a preference, will be running more than 7 app servers, or if AWS has been failing to provision servers for you in previous attempts to create the stack. App servers communicate with one another extensively, so 'cluster' is the preferred setting if you can tolerate some risk of downtime if there are AZ-wide outages, which are rare."
    Default: cluster
    AllowedValues:
      - cluster
      - spread
      - none
  DbBackupRetentionPeriod:
    Type: Number
    Description: "Number of days your AWS Aurora database backups will be retained for."
    Default: 14
  DbMaxCapacity:
    Type: Number
    Description: "Maximum ACU Capacity for the database. The database will be a serverless Aurora PostgreSQL-compatible cluster. Increasing the Maximum ACUs will increase the available resources to your instance for database queries."
    MinValue: 2
    MaxValue: 384
    Default: 2
  RestoreDbSnapshotIdentifier:
    Type: String
    Description: "Leave blank if you are not restoring from a backup. To restore from an existing Hubs Cloud backup, specify the AWS Aurora database snapshot identifier to restore from. (eg mystack-snapshot-mystack-app-db-xxxxx) Also you'll need to specify the other parameters below. WARNING: do *not* change this value after your stack is created, otherwise you will replace your existing database!"
  RestoreAppDbSecretArn:
    Type: String
    Description: "Leave blank if you are not restoring from a backup. To restore from an existing Hubs Cloud backup, specify the ARN for the database secret from the instance being restored from. (eg arn:aws:secretsmanager:<region>:<account-id>:secret:AppDbSecret-xxxxxxxxx)"
  RestoreStackName:
    Type: String
    Description: "Leave blank if you are not restoring from a backup. To restore from an existing Hubs Cloud backup, specify the stack name being restored from. To restore, the secrets stored in Parameter Store must still be available from the stack being restored from. These parameters should still exist even if you deleted the old stack, unless you manually removed them."
  RestoreStackRegion:
    Type: String
    Description: "Leave blank if you are not restoring from a backup. To restore from an existing Hubs Cloud backup, specify the region of the stack being restored from."
    AllowedValues: ["", "us-east-1", "us-west-2", "us-east-2", "ap-northeast-1", "eu-west-1"]
  RestoreBackupVaultName:
    Type: String
    Description: "Leave blank if you are not restoring from a backup. To restore from an existing Hubs Cloud backup, specify the AWS Backup Vault Name to restore storage from. (eg mystack-daily-backup-xxxxxxx)"
  RestoreRecoveryPointArn:
    Type: String
    Description: "Leave blank if you are not restoring from a backup. To restore from an existing Hubs Cloud backup, specify the AWS Backup Vault's Recovery Point ARN to restore storage from. (eg arn:aws:backup:<region>:<account id>:recovery-point:xxxxxxxx)"
  NewCMKForDiskEncryption:
    Type: String
    Description: "Select 'Yes' if you'd like to create a dedicated CMK in KMS for database and backup encryption. KMS charges for a single managed key will apply."
    Default: "No - Use the AWS Managed Key"
    AllowedValues:
      - No - Use the AWS Managed Key
      - Yes - Create a new CMK
  SubnetAZs:
    Type: String
    Description: "If your stack is failing to create, and the 'Events' tab shows the error 'Value (xxx) for parameter availabilityZone is invalid. Subnets can currently only be created in the following availability zones: X, Y', you will need to select an alternative subnet configuration here. This is an issue with AWS: https://github.com/widdix/aws-cf-templates/issues/36"
    Default: "Use zone a and b"
    AllowedValues:
      - Use zone a and b
      - Use zone b and c
      - Use zone a and c
      - Use zone b and d
      - Use zone c and d
  MaintenenceWindow:
    Type: String
    Description: Server maintenence window. Your server will be kept up-to-date with new features and fixes. Server upgrades will happen approximately once a month, and will result in a brief period of downtime, usually 30 seconds or so. We offer two maintenence windows to perform these updates.
    Default: "10:00-11:00 GMT (02:00-03:00 PT)"
    AllowedValues: ["10:00-11:00 GMT (02:00-03:00 PT)", "22:00-23:00 GMT (14:00-15:00 PT)"]
  ChannelType:
    Type: String
    Description: Software release to run on your servers. The 'unstable' channel will receive updates before 'stable', but may break your stack.
    Default: "Stable"
    AllowedValues: ["Stable", "Unstable"]
  LoadBalancingMethod:
    Type: String
    Description: Method for load balancing requests to app servers. If you only have one or a few app servers, and would like to save on AWS costs, choose DNS Round Robin. If you have several app servers or would like improved load balancing, you can also use an Application Load Balancer, which will incur additional costs. If you are using an domain not on Route 53, be sure to note the "AddressForRootDomain" in the Outputs tab after the stack update to set your DNS to point to the ALB.
    Default: "DNS Round Robin"
    AllowedValues: ["DNS Round Robin", "Application Load Balancer"]
  AutoPauseDb:
    Type: String
    Description: Hubs Cloud uses the Aurora Serverless database, which can greatly save costs by pausing the database when your Hubs Cloud instance is not in use. However, when the database is paused, it can take up to 20 seconds for your site to come back up when you visit it. You can turn off database pausing if you'd like to avoid any delay in loading your site. Turning off pausing will incur continuous hourly database costs. Pricing info can be found at https://aws.amazon.com/rds/aurora/serverless/
    Default: "Yes - Pause database when not in use"
    AllowedValues: ["Yes - Pause database when not in use", "No - Pay for database continuously to prevent loading delays"]
  StackOffline:
    Type: String
    Description: To save costs, you can switch your stack from being Online to Offline when it is not needed. This will shut down the servers while keeping all of your data. Once your service is switched back to Online, it will come back up just how you left it.
    AllowedValues: ["Online", "Offline - Temporarily shut off servers"]
    Default: "Online"
  StackOfflineRedirectUrl:
    Type: String
    Description: When your stack is set to Offline, visitors will be redirected to this URL.
  DatabaseMonthlyBudget:
    Type: Number
    Description: If you do not want a monthly budget, set this to zero. To save costs, your AWS Aurora Serverless database will be shut down when nobody is hitting your site. When visitors are using your site, you'll incur database costs. To avoid unexpected charges, you can set a monthly budget. If you are running multiple Hubs Cloud instances, this budget should reflect your maximum allowed cost across *all* your Hubs Cloud instances in this region. This instance will automatically switch into Offline mode if the Aurora Serverless database charges across all your instances in this region exceed this budget. A minimum $20 budget is recommended and will provide more than 40 hours a week of connectivity for an instance. You only pay for what you use. Leave this field blank to fall back to your "Max database capacity" setting in "Advanced" to limit your database cost. Pricing info can be found at https://aws.amazon.com/rds/aurora/serverless/
    Default: 0
  MaxStorage:
    Type: Number
    Description: When users upload scenes, avatars, or files, they will use disk storage. You only pay for the storage you use. You can set a maximum storage amount here (in GB) to ensure there are no unexpected charges. Pricing info can be found at https://aws.amazon.com/efs/pricing/
    MinValue: 5
    MaxValue: 1048576
    Default: 100

Mappings:
  Regions:
    us-east-1:
      Abbreviation: USE1
    us-west-2:
      Abbreviation: USW2
    us-east-2:
      ImageId: ami-0ba1d18b92224066a
      Abbreviation: USE2
    ap-northeast-1:
      Abbreviation: APN1
    eu-west-1:
      Abbreviation: EU

  ServicesMeta:
    RetExternal:
      Port: 443
    RetInternal:
      Port: 4000
    JanusExternal:
      Port: 8443
    JanusAdmin:
      Port: 7000
    JanusWebRTCFrom:
      Port: 20000
    JanusWebRTCTo:
      Port: 60000
    YTDL:
      Port: 8080
    BioCensus:
      Port: 9631
    Ssh:
      Port: 22
    PostgreSQL:
      Port: 5432

  InstanceTypeMeta:
    # Some instance types do not support cluster placement, so use spread
    t2.micro:
      PlacementForCluster: spread
    t2.small:
      PlacementForCluster: spread
    t3.medium:
      PlacementForCluster: spread
    t3.large:
      PlacementForCluster: spread
    c5.large:
      PlacementForCluster: cluster
    c5.xlarge:
      PlacementForCluster: cluster
    c5.2xlarge:
      PlacementForCluster: cluster
    c5.4xlarge:
      PlacementForCluster: cluster

Conditions:
  HasManagedDomain: !Equals [!Ref IsDomainOnRoute53, "Yes - My domain is set up on Route 53"]
  HasUnmangedDomain: !Not [Condition: HasManagedDomain]
  HasStreamingServers: !And [!Equals [!Ref StackOffline, "Online"], !Not [!Equals [!Ref StreamInstanceCount, 0]]]
  AppIsNoPlacement: !Equals [!Ref AppPlacementGroupStrategy, none]
  AppIsClusterPlacement: !Equals [!Ref AppPlacementGroupStrategy, cluster]
  HasEmailSubdomain: !Equals [!Ref EmailSubdomain, ""]
  CreateDiskEncryptionKey: !Equals [!Ref NewCMKForDiskEncryption, "Yes - Create a new CMK"]
  SubnetChoiceA: !Equals [!Ref SubnetAZs, "Use zone a and b"]
  SubnetChoiceB: !Equals [!Ref SubnetAZs, "Use zone b and c"]
  SubnetChoiceC: !Equals [!Ref SubnetAZs, "Use zone a and c"]
  SubnetChoiceD: !Equals [!Ref SubnetAZs, "Use zone b and d"]
  IsStableChannel: !Equals [!Ref ChannelType, "Stable"]
  IsWindowA: !Equals [!Ref MaintenenceWindow, "10:00-11:00 GMT (02:00-03:00 PT)"]
  IsOnline: !Equals [!Ref StackOffline, "Online"]
  IsOffline: !Not [Condition: IsOnline]
  HasOfflineRedirectUrl: !Not [!Equals [!Ref StackOfflineRedirectUrl, ""]]
  PerformOfflineRedirect: !And [ Condition: IsOffline, Condition: HasOfflineRedirectUrl ]
  PerformOfflineRedirectWithUnmanagedDomain: !And [Condition: PerformOfflineRedirect, Condition: HasUnmangedDomain]
  EnableDbAutoPause: !Equals [!Ref AutoPauseDb, "Yes - Pause database when not in use"]
  HasDbMonthlyBudget: !Not [!Equals [!Ref DatabaseMonthlyBudget, 0]]
  IsNotRestore: !Equals [!Ref RestoreDbSnapshotIdentifier, ""]
  IsRestore: !Not [Condition: IsNotRestore]

  # NOTE: keep the ALB around if we are doing an offline redirect *and* we have an unmanaged domain, because otherwise
  # it would require the user to go update their external DNS CNAME to get the redirect to work. The downside is that
  # for this specific scenario the user will continue to pay for the ALB.
  RequestedALB: !Equals [!Ref LoadBalancingMethod, "Application Load Balancer"]
  HasALB: !And [!Or [Condition: IsOnline, Condition: PerformOfflineRedirectWithUnmanagedDomain], Condition: RequestedALB]

Resources:

# VPC - Two subnets for public + private
  VPC:
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: !Sub '10.${ClassB}.0.0/16'
      EnableDnsSupport: true
      EnableDnsHostnames: true
      InstanceTenancy: default
      Tags:
      - Key: Name
        Value: !Sub '${AWS::StackName} 10.${ClassB}.0.0/16'
  InternetGateway:
    Type: AWS::EC2::InternetGateway
    Properties:
      Tags:
      - Key: Name
        Value: !Sub '${AWS::StackName} 10.${ClassB}.0.0/16'
  VPCGatewayAttachment:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      VpcId: !Ref VPC
      InternetGatewayId: !Ref InternetGateway
  SubnetAPublic:
    Type: AWS::EC2::Subnet
    Properties:
      AvailabilityZone: !Select [!If [SubnetChoiceA, 0, !If [SubnetChoiceB, 1, !If [SubnetChoiceC, 0, !If [SubnetChoiceD, 1, 2]]]], !GetAZs '']
      CidrBlock: !Sub '10.${ClassB}.0.0/20'
      MapPublicIpOnLaunch: true
      VpcId: !Ref VPC
      Tags:
      - Key: Name
        Value: !Sub '${AWS::StackName} A public'
      - Key: Reach
        Value: public
  SubnetAPrivate:
    Type: AWS::EC2::Subnet
    Properties:
      AvailabilityZone: !Select [!If [SubnetChoiceA, 0, !If [SubnetChoiceB, 1, !If [SubnetChoiceC, 0, !If [SubnetChoiceD, 1, 2]]]], !GetAZs '']
      CidrBlock: !Sub '10.${ClassB}.16.0/20'
      VpcId: !Ref VPC
      Tags:
      - Key: Name
        Value: !Sub '${AWS::StackName} A private'
      - Key: Reach
        Value: private
  SubnetBPublic:
    Type: AWS::EC2::Subnet
    Properties:
      AvailabilityZone: !Select [!If [SubnetChoiceA, 1, !If [SubnetChoiceB, 2, !If [SubnetChoiceC, 2, !If [SubnetChoiceD, 3, 3]]]], !GetAZs '']
      CidrBlock: !Sub '10.${ClassB}.32.0/20'
      MapPublicIpOnLaunch: true
      VpcId: !Ref VPC
      Tags:
      - Key: Name
        Value: !Sub '${AWS::StackName} B public'
      - Key: Reach
        Value: public
  SubnetBPrivate:
    Type: AWS::EC2::Subnet
    Properties:
      AvailabilityZone: !Select [!If [SubnetChoiceA, 1, !If [SubnetChoiceB, 2, !If [SubnetChoiceC, 2, !If [SubnetChoiceD, 3, 3]]]], !GetAZs '']
      CidrBlock: !Sub '10.${ClassB}.48.0/20'
      VpcId: !Ref VPC
      Tags:
      - Key: Name
        Value: !Sub '${AWS::StackName} B private'
      - Key: Reach
        Value: private
  RouteTableAPublic:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref VPC
      Tags:
      - Key: Name
        Value: !Sub '${AWS::StackName} A public'
  RouteTableAPrivate:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref VPC
      Tags:
      - Key: Name
        Value: !Sub '${AWS::StackName} A private'
  RouteTableBPublic:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref VPC
      Tags:
      - Key: Name
        Value: !Sub '${AWS::StackName} B public'
  RouteTableBPrivate:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref VPC
      Tags:
      - Key: Name
        Value: !Sub '${AWS::StackName} B private'
  RouteTableAssociationAPublic:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref SubnetAPublic
      RouteTableId: !Ref RouteTableAPublic
  RouteTableAssociationAPrivate:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref SubnetAPrivate
      RouteTableId: !Ref RouteTableAPrivate
  RouteTableAssociationBPublic:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref SubnetBPublic
      RouteTableId: !Ref RouteTableBPublic
  RouteTableAssociationBPrivate:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref SubnetBPrivate
      RouteTableId: !Ref RouteTableBPrivate
  RouteTablePublicAInternetRoute:
    Type: AWS::EC2::Route
    DependsOn: VPCGatewayAttachment
    Properties:
      RouteTableId: !Ref RouteTableAPublic
      DestinationCidrBlock: '0.0.0.0/0'
      GatewayId: !Ref InternetGateway
  RouteTablePublicBInternetRoute:
    Type: AWS::EC2::Route
    DependsOn: VPCGatewayAttachment
    Properties:
      RouteTableId: !Ref RouteTableBPublic
      DestinationCidrBlock: '0.0.0.0/0'
      GatewayId: !Ref InternetGateway
  NetworkAclPublic:
    Type: AWS::EC2::NetworkAcl
    Properties:
      VpcId: !Ref VPC
      Tags:
      - Key: Name
        Value: !Sub '${AWS::StackName} Public'
  NetworkAclPrivate:
    Type: AWS::EC2::NetworkAcl
    Properties:
      VpcId: !Ref VPC
      Tags:
      - Key: Name
        Value: !Sub '${AWS::StackName} Private'
  SubnetNetworkAclAssociationAPublic:
    Type: AWS::EC2::SubnetNetworkAclAssociation
    Properties:
      SubnetId: !Ref SubnetAPublic
      NetworkAclId: !Ref NetworkAclPublic
  SubnetNetworkAclAssociationAPrivate:
    Type: AWS::EC2::SubnetNetworkAclAssociation
    Properties:
      SubnetId: !Ref SubnetAPrivate
      NetworkAclId: !Ref NetworkAclPrivate
  SubnetNetworkAclAssociationBPublic:
    Type: AWS::EC2::SubnetNetworkAclAssociation
    Properties:
      SubnetId: !Ref SubnetBPublic
      NetworkAclId: !Ref NetworkAclPublic
  SubnetNetworkAclAssociationBPrivate:
    Type: AWS::EC2::SubnetNetworkAclAssociation
    Properties:
      SubnetId: !Ref SubnetBPrivate
      NetworkAclId: !Ref NetworkAclPrivate
  NetworkAclEntryInPublicAllowAll:
    Type: AWS::EC2::NetworkAclEntry
    Properties:
      NetworkAclId: !Ref NetworkAclPublic
      RuleNumber: 99
      Protocol: -1
      RuleAction: allow
      Egress: false
      CidrBlock: '0.0.0.0/0'
  NetworkAclEntryOutPublicAllowAll:
    Type: AWS::EC2::NetworkAclEntry
    Properties:
      NetworkAclId: !Ref NetworkAclPublic
      RuleNumber: 99
      Protocol: -1
      RuleAction: allow
      Egress: true
      CidrBlock: '0.0.0.0/0'
  NetworkAclEntryInPrivateAllowVPC:
    Type: AWS::EC2::NetworkAclEntry
    Properties:
      NetworkAclId: !Ref NetworkAclPrivate
      RuleNumber: 99
      Protocol: -1
      RuleAction: allow
      Egress: false
      CidrBlock: '0.0.0.0/0'
  NetworkAclEntryOutPrivateAllowVPC:
    Type: AWS::EC2::NetworkAclEntry
    Properties:
      NetworkAclId: !Ref NetworkAclPrivate
      RuleNumber: 99
      Protocol: -1
      RuleAction: allow
      Egress: true
      CidrBlock: '0.0.0.0/0'
# Lambda Copy
  CopySpeelycaptorLambda:
    Type: Custom::CopySpeelycaptorLambda
    UpdateReplacePolicy: Retain
    DependsOn: LambdaBucket
    Properties:
      ServiceToken: !GetAtt CopyFileFunction.Arn
      DestBucket: !Ref LambdaBucket
      SourceBucket: polycosm-assets-prod-77ae26402152f4ea
      Prefix: ""
      Objects:
        - lambdas/speelycaptor/speelycaptor-0.1.2.zip
  CopyNearsparkLambda:
    Type: Custom::CopyNearsparkLambda
    UpdateReplacePolicy: Retain
    DependsOn: LambdaBucket
    Properties:
      ServiceToken: !GetAtt CopyFileFunction.Arn
      DestBucket: !Ref LambdaBucket
      SourceBucket: polycosm-assets-prod-77ae26402152f4ea
      Prefix: ""
      Objects:
        - lambdas/nearspark/nearspark-0.1.0.zip
  CopyPhotomnemonicLambda:
    Type: Custom::CopyPhotomnemonicLambda
    UpdateReplacePolicy: Retain
    DependsOn: LambdaBucket
    Properties:
      ServiceToken: !GetAtt CopyFileFunction.Arn
      DestBucket: !Ref LambdaBucket
      SourceBucket: polycosm-assets-prod-77ae26402152f4ea
      Prefix: ""
      Objects:
        - lambdas/photomnemonic/photomnemonic-0.1.0.zip
  CopySesLambda:
    Type: Custom::CopySesLambda
    UpdateReplacePolicy: Retain
    DependsOn: LambdaBucket
    Properties:
      ServiceToken: !GetAtt CopyFileFunction.Arn
      DestBucket: !Ref LambdaBucket
      SourceBucket: polycosm-assets-prod-77ae26402152f4ea
      Prefix: ""
      Objects:
        - lambdas/aws-cfn-ses-domain/aws-cfn-ses-domain-0.4.zip
  CopyKeymasterLambda:
    Type: Custom::CopyKeymasterLambda
    UpdateReplacePolicy: Retain
    DependsOn: LambdaBucket
    Properties:
      ServiceToken: !GetAtt CopyFileFunction.Arn
      DestBucket: !Ref LambdaBucket
      SourceBucket: polycosm-assets-prod-77ae26402152f4ea
      Prefix: ""
      Objects:
        - lambdas/keymaster/keymaster-0.1.9.zip

## route53dependency
  Route53DependencyLambda:
    Metadata:
      Source: https://github.com/sonyxperiadev/amazon-custom-resources/tree/master/route53-dependency
      Version: 1.0.0
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "${AWS::StackName}-route53-dependency"
      Description: Lookup Route 53 info
      Handler: index.handler
      Role: !GetAtt Route53DependencyRole.Arn
      Runtime: nodejs10.x
      Timeout: 900
      Code:
        ZipFile: |
          'use strict';

          function route53Dependency(properties, callback) {
            if (!properties.Id && !properties.Domain)
              callback("Zone id or domain not specified");

            var aws = require("aws-sdk");
            var route53 = new aws.Route53();

            var responseData = {};
            console.log('route53Dependency', properties);
            route53.listHostedZones({}, function(err, data) {
              console.log('listHostedZones', err, data);
              if (err)
                return callback(err);

              var zones = data.HostedZones;
              var matching = zones.filter(function(zone) {
                if (properties.Id) {
                  return zone.Id === "/hostedzone/" + properties.Id;
                } else {
                  var tldParts = properties.Domain.split(".");
                  var tld = tldParts[tldParts.length - 2] + "." + tldParts[tldParts.length - 1];
                  return zone.Name === tld + ".";
                }
              });
              if (matching.length != 1)
                return callback('Exactly one matching zone is allowed ' + zones);
              var match = matching[0];
              delete match.Config;
              delete match.CallerReference;
              match.Id = match.Id.split('/')[2];
              match.Name = match.Name.substring(0, match.Name.length-1);
              return callback(null, match);
            });
          }

          route53Dependency.handler = function(event, context) {
            console.log(JSON.stringify(event, null, '  '));

            if (event.RequestType == 'Delete') {
              return sendResponse(event, context, "SUCCESS");
            }

            route53Dependency(event.ResourceProperties, function(err, result) {
              var status = err ? 'FAILED' : 'SUCCESS';
              return sendResponse(event, context, status, result, err);
            });
          };

          function getReason(err) {
            if (err)
              return err.message;
            else
              return '';
          }

          function sendResponse(event, context, status, data, err) {
            var responseBody = {
              StackId: event.StackId,
              RequestId: event.RequestId,
              LogicalResourceId: event.LogicalResourceId,
              PhysicalResourceId: 'route53Dependency-' + (event.ResourceProperties.Domain || event.ResourceProperties.Id),
              Status: status,
              Reason: getReason(err) + " See details in CloudWatch Log: " + context.logStreamName,
              Data: data
            };

            console.log("RESPONSE:\n", responseBody);
            var json = JSON.stringify(responseBody);

            var https = require("https");
            var url = require("url");

            var parsedUrl = url.parse(event.ResponseURL);
            var options = {
              hostname: parsedUrl.hostname,
              port: 443,
              path: parsedUrl.path,
              method: "PUT",
              headers: {
                "content-type": "",
                "content-length": json.length
              }
            };

            var request = https.request(options, function(response) {
              console.log("STATUS: " + response.statusCode);
              console.log("HEADERS: " + JSON.stringify(response.headers));
              context.done(null, data);
            });

            request.on("error", function(error) {
              console.log("sendResponse Error:\n", error);
              context.done(error);
            });

            request.on("end", function() {
              console.log("end");
            });
            request.write(json);
            request.end();
          }


          module.exports = route53Dependency;
  Route53DependencyRole:
    Properties:
      RoleName: !Sub "${AWS::StackName}-Route53Dependency"
      AssumeRolePolicyDocument:
        Statement:
          - Action:
              - sts:AssumeRole
            Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
        Version: '2012-10-17'
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
        - arn:aws:iam::aws:policy/service-role/AWSLambdaRole
      Policies:
        - PolicyDocument:
            Statement:
              - Action:
                  - route53:ListHostedZones
                Effect: Allow
                Resource: "*"
            Version: '2012-10-17'
          PolicyName: !Sub '${AWS::StackName}Route53DependencyCustomPolicy'
    Type: AWS::IAM::Role

# URL parsing for offline redirector
  ParseURL:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "${AWS::StackName}-parse-url"
      Description: Parse a URL into its constituent parts for redirector
      Handler: index.handler
      Role: !GetAtt ParseURLRole.Arn
      Runtime: nodejs10.x
      Timeout: 900
      Code:
        ZipFile: |
          const URL = require('url');
          const parseURL = {};
          
          function btoa(s) {
            return Buffer.from(s).toString('base64');
          }
          
          parseURL.handler = function(event, context) {
            const url = event.ResourceProperties.URL || "https://en.wikipedia.org/wiki/Rubber_duck";
          
            try {
              const parsed = URL.parse(url);
              const pathname = parsed.pathname;
          
              return sendResponse(event, context, "SUCCESS", {
                S3ReplaceKeyPrefixWith: `${parsed.pathname.substring(1)}${parsed.search || ""}${parsed.hash || ""}`,
                S3Protocol: parsed.protocol.replace(":", ""),
                S3Hostname: parsed.host,
                ALBProtocol: parsed.protocol.replace(":", "").toUpperCase(),
                ALBPort: parsed.port,
                ALBHost: parsed.host,
                ALBPath: parsed.pathname,
                ALBQuery: `${parsed.search || ""}${parsed.hash || ""}`.replace(/^\?/, "")
              });
            } catch (e) {
              return sendResponse(event, context, "FAILED", null, `Invalid URL specified: ${url}`);
            }
          };
          
          function getReason(err) {
            if (err)
              return err.message;
            else
              return '';
          }
          
          function sendResponse(event, context, status, data, err) {
            var responseBody = {
              StackId: event.StackId,
              RequestId: event.RequestId,
              LogicalResourceId: event.LogicalResourceId,
              PhysicalResourceId: 'parseUrl-' + btoa(event.ResourceProperties.URL),
              Status: status,
              Reason: getReason(err) + " See details in CloudWatch Log: " + context.logStreamName,
              Data: data
            };
          
            console.log("RESPONSE:\n", responseBody);
            var json = JSON.stringify(responseBody);
          
            var https = require("https");
            var url = require("url");
          
            var parsedUrl = url.parse(event.ResponseURL);
            var options = {
              hostname: parsedUrl.hostname,
              port: 443,
              path: parsedUrl.path,
              method: "PUT",
              headers: {
                "content-type": "",
                "content-length": json.length
              }
            };
          
            var request = https.request(options, function(response) {
              console.log("STATUS: " + response.statusCode);
              console.log("HEADERS: " + JSON.stringify(response.headers));
              context.done(null, data);
            });
          
            request.on("error", function(error) {
              console.log("sendResponse Error:\n", error);
              context.done(error);
            });
          
            request.on("end", function() {
              console.log("end");
            });
            request.write(json);
            request.end();
          }
          
          module.exports = parseURL;

  ParseURLRole:
    Properties:
      RoleName: !Sub "${AWS::StackName}-ParseURLRole"
      AssumeRolePolicyDocument:
        Statement:
          - Action:
              - sts:AssumeRole
            Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
        Version: '2012-10-17'
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
        - arn:aws:iam::aws:policy/service-role/AWSLambdaRole
    Type: AWS::IAM::Role

# CustomAcmCertificateLambda
  CustomAcmCertificateLambda:
    Metadata:
      Source: https://github.com/dflook/cloudformation-dns-certificate
      Version: 1.7.1
    Properties:
      Code:
        ZipFile: "T=RuntimeError\nimport copy,hashlib as t,json,logging as B,time\
          \ as b\nfrom boto3 import client as K\nfrom botocore.exceptions import ClientError\
          \ as u,ParamValidationError as v\nfrom botocore.vendored import requests\
          \ as w\nA=B.getLogger()\nA.setLevel(B.INFO)\nD=A.info\nS=A.exception\nd=json.dumps\n\
          M=copy.copy\ne=b.sleep\ndef handler(event,c):\n\tA9='OldResourceProperties';A8='Update';A7='Delete';A6='None';A5='acm';A4='FAILED';A3='properties';A2='stack-id';A1='logical-id';A0='DNS';s='Old';r='Certificate';q='LogicalResourceId';p='DomainName';o='ValidationMethod';n='Route53RoleArn';m='Region';a='RequestType';Z='Reinvoked';Y='StackId';X=None;R='Status';Q='Key';P='';O=True;N='DomainValidationOptions';L=False;J='ResourceProperties';I='cloudformation:';H='Value';G='CertificateArn';F='Tags';C='PhysicalResourceId';A=event;f=c.get_remaining_time_in_millis;D(A)\n\
          \tdef g():\n\t\tD=M(B)\n\t\tfor H in ['ServiceToken',m,F,n]:D.pop(H,X)\n\
          \t\tif o in B:\n\t\t\tif B[o]==A0:\n\t\t\t\tfor I in set([B[p]]+B.get('SubjectAlternativeNames',[])):k(I)\n\
          \t\t\t\tdel D[N]\n\t\tA[C]=E.request_certificate(IdempotencyToken=y,**D)[G];l()\n\
          \tdef U(a):\n\t\twhile O:\n\t\t\ttry:E.delete_certificate(**{G:a});return\n\
          \t\t\texcept u as B:\n\t\t\t\tS(P);A=B.response['Error']['Code']\n\t\t\t\
          \tif A=='ResourceInUseException':\n\t\t\t\t\tif f()/1000<30:raise\n\t\t\t\
          \t\te(5);continue\n\t\t\t\tif A in['ResourceNotFoundException','ValidationException']:return\n\
          \t\t\t\traise\n\t\t\texcept v:return\n\tdef V(props):\n\t\tfor J in E.get_paginator('list_certificates').paginate():\n\
          \t\t\tfor B in J['CertificateSummaryList']:\n\t\t\t\tD(B);C={A[Q]:A[H]for\
          \ A in E.list_tags_for_certificate(**{G:B[G]})[F]}\n\t\t\t\tif C.get(I+A1)==A[q]and\
          \ C.get(I+A2)==A[Y]and C.get(I+A3)==hash(props):return B[G]\n\tdef h():\n\
          \t\tif A.get(Z,L):raise T('Certificate not issued in time')\n\t\tA[Z]=O;D(A);K('lambda').invoke(FunctionName=c.invoked_function_arn,InvocationType='Event',Payload=d(A).encode())\n\
          \tdef i():\n\t\twhile f()/1000>30:\n\t\t\tB=E.describe_certificate(**{G:A[C]})[r];D(B)\n\
          \t\t\tif B[R]=='ISSUED':return O\n\t\t\telif B[R]==A4:raise T(B.get('FailureReason',P))\n\
          \t\t\te(5)\n\t\treturn L\n\tdef x():B=M(A[s+J]);B.pop(F,X);C=M(A[J]);C.pop(F,X);return\
          \ B!=C\n\tdef j():\n\t\tW='Type';V='Name';U='HostedZoneId';T='ValidationStatus';S='PENDING_VALIDATION';L='ResourceRecord'\n\
          \t\tif B.get(o)!=A0:return\n\t\twhile O:\n\t\t\tI=E.describe_certificate(**{G:A[C]})[r];D(I)\n\
          \t\t\tif I[R]!=S:return\n\t\t\tif not[A for A in I.get(N,[{}])if T not in\
          \ A or L not in A]:break\n\t\t\tb.sleep(1)\n\t\tfor F in I[N]:\n\t\t\tif\
          \ F[T]==S:M=k(F[p]);P=M.get(n,B.get(n));J=K('sts').assume_role(RoleArn=P,RoleSessionName=(r+A[q])[:64],DurationSeconds=900)['Credentials']if\
          \ P is not X else{};Q=K('route53',aws_access_key_id=J.get('AccessKeyId'),aws_secret_access_key=J.get('SecretAccessKey'),aws_session_token=J.get('SessionToken')).change_resource_record_sets(**{U:M[U],'ChangeBatch':{'Comment':'Domain\
          \ validation for '+A[C],'Changes':[{'Action':'UPSERT','ResourceRecordSet':{V:F[L][V],W:F[L][W],'TTL':60,'ResourceRecords':[{H:F[L][H]}]}}]}});D(Q)\n\
          \tdef k(n):\n\t\tC='.';n=n.rstrip(C);D={A[p].rstrip(C):A for A in B[N]};A=n.split(C)\n\
          \t\twhile len(A):\n\t\t\tif C.join(A)in D:return D[C.join(A)]\n\t\t\tA=A[1:]\n\
          \t\traise T(N+' missing'+' for '+n)\n\thash=lambda v:t.new('md5',d(v,sort_keys=O).encode()).hexdigest()\n\
          \tdef l():B=M(A[J].get(F,[]));B+=[{Q:I+A1,H:A[q]},{Q:I+A2,H:A[Y]},{Q:I+'stack-name',H:A[Y].split('/')[1]},{Q:I+A3,H:hash(A[J])}];E.add_tags_to_certificate(**{G:A[C],F:B})\n\
          \tdef W():D(A);B=w.put(A['ResponseURL'],json=A,headers={'content-type':P});B.raise_for_status()\n\
          \ttry:\n\t\ty=hash(A['RequestId']+A[Y]);B=A[J];E=K(A5,region_name=B.get(m));A[R]='SUCCESS'\n\
          \t\tif A[a]=='Create':\n\t\t\tif A.get(Z,L)is L:A[C]=A6;g()\n\t\t\tj()\n\
          \t\t\tif not i():return h()\n\t\telif A[a]==A7:\n\t\t\tif A[C]!=A6:\n\t\t\
          \t\tif A[C].startswith('arn:'):U(A[C])\n\t\t\t\telse:U(V(B))\n\t\telif A[a]==A8:\n\
          \t\t\tif x():\n\t\t\t\tD(A8)\n\t\t\t\tif V(B)==A[C]:\n\t\t\t\t\ttry:E=K(A5,region_name=A[A9].get(m));D(A7);U(V(A[A9]))\n\
          \t\t\t\t\texcept:S(P)\n\t\t\t\t\treturn W()\n\t\t\t\tif A.get(Z,L)is L:g()\n\
          \t\t\t\tj()\n\t\t\t\tif not i():return h()\n\t\t\telse:\n\t\t\t\tif F in\
          \ A[s+J]:E.remove_tags_from_certificate(**{G:A[C],F:A[s+J][F]})\n\t\t\t\t\
          l()\n\t\telse:raise T(A[a])\n\t\treturn W()\n\texcept Exception as z:S(P);A[R]=A4;A['Reason']=str(z);return\
          \ W()"
      Description: Cloudformation custom resource for DNS validated certificates
      Handler: index.handler
      Role: !GetAtt CustomAcmCertificateLambdaExecutionRole.Arn
      Runtime: python3.6
      Timeout: 900
    Type: AWS::Lambda::Function
  CustomAcmCertificateLambdaExecutionRole:
    Properties:
      RoleName: !Sub "${AWS::StackName}-CustomAcmCertificateLambdaExecution"
      AssumeRolePolicyDocument:
        Statement:
          - Action:
              - sts:AssumeRole
            Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
        Version: '2012-10-17'
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
        - arn:aws:iam::aws:policy/service-role/AWSLambdaRole
      Policies:
        - PolicyDocument:
            Statement:
              - Action:
                  - acm:AddTagsToCertificate
                  - acm:DeleteCertificate
                  - acm:DescribeCertificate
                  - acm:RemoveTagsFromCertificate
                Effect: Allow
                Resource:
                  - !Sub 'arn:aws:acm:*:${AWS::AccountId}:certificate/*'
              - Action:
                  - acm:RequestCertificate
                  - acm:ListTagsForCertificate
                  - acm:ListCertificates
                Effect: Allow
                Resource:
                  - '*'
              - Action:
                  - route53:ChangeResourceRecordSets
                Effect: Allow
                Resource:
                  - arn:aws:route53:::hostedzone/*
            Version: '2012-10-17'
          PolicyName: !Sub '${AWS::StackName}CustomAcmCertificateLambdaExecutionPolicy'
    Type: AWS::IAM::Role

# Zones + SSL Certs
  ExternalZoneInfo:
    Type: Custom::Route53
    Condition: HasManagedDomain
    Properties:
      Domain: !Ref DomainName
      ServiceToken: !GetAtt Route53DependencyLambda.Arn

  ShortlinkZoneInfo:
    Type: Custom::Route53
    Properties:
      Id: !Ref ShortlinkZone
      ServiceToken: !GetAtt Route53DependencyLambda.Arn

  InternalZoneInfo:
    Type: Custom::Route53
    Properties:
      Id: !Ref InternalZone
      ServiceToken: !GetAtt Route53DependencyLambda.Arn

  EmailZoneInfo:
    Type: Custom::Route53
    Properties:
      Id: !Ref EmailZone
      ServiceToken: !GetAtt Route53DependencyLambda.Arn

  ExternalZoneSSLCert:
    Type: Custom::DNSCertificate
    Condition: HasManagedDomain
    Properties: 
      DomainName: !GetAtt ExternalZoneInfo.Name
      DomainValidationOptions:
        - DomainName: !GetAtt ExternalZoneInfo.Name
          HostedZoneId: !GetAtt ExternalZoneInfo.Id
      ValidationMethod: DNS
      Region: !Sub "${AWS::Region}"
      ServiceToken: !GetAtt CustomAcmCertificateLambda.Arn

  ExternalZoneSSLCertEast:
    Type: Custom::DNSCertificate
    Condition: HasManagedDomain
    Properties: 
      DomainName: !GetAtt ExternalZoneInfo.Name
      SubjectAlternativeNames:
        - !Sub '${AWS::StackName}-cors-proxy.${InternalZoneInfo.Name}'
      DomainValidationOptions:
        - DomainName: !GetAtt ExternalZoneInfo.Name
          HostedZoneId: !GetAtt ExternalZoneInfo.Id
        - DomainName: !Sub '${AWS::StackName}-cors-proxy.${InternalZoneInfo.Name}'
          HostedZoneId: !GetAtt InternalZoneInfo.Id
      ValidationMethod: DNS
      Region: us-east-1
      ServiceToken: !GetAtt CustomAcmCertificateLambda.Arn

  ShortlinkZoneSSLCertEast:
    Type: Custom::DNSCertificate
    Properties: 
      DomainName: !GetAtt ShortlinkZoneInfo.Name
      DomainValidationOptions:
        - DomainName: !GetAtt ShortlinkZoneInfo.Name
          HostedZoneId: !GetAtt ShortlinkZoneInfo.Id
      ValidationMethod: DNS
      Region: us-east-1
      ServiceToken: !GetAtt CustomAcmCertificateLambda.Arn

  InternalZoneSSLCert:
    Type: Custom::DNSCertificate
    Properties: 
      DomainName: !Sub '*.${InternalZoneInfo.Name}'
      DomainValidationOptions:
        - DomainName: !GetAtt InternalZoneInfo.Name
          HostedZoneId: !Ref InternalZone
      ValidationMethod: DNS
      Region: !Sub "${AWS::Region}"
      ServiceToken: !GetAtt CustomAcmCertificateLambda.Arn

  InternalZoneSSLCertEast:
    Type: Custom::DNSCertificate
    Properties: 
      DomainName: !Sub '*.${InternalZoneInfo.Name}'
      DomainValidationOptions:
        - DomainName: !GetAtt InternalZoneInfo.Name
          HostedZoneId: !Ref InternalZone
      ValidationMethod: DNS
      Region: us-east-1
      ServiceToken: !GetAtt CustomAcmCertificateLambda.Arn

# SESDomain
  SESDomainRole:
   Type: AWS::IAM::Role
   Properties:
     RoleName: !Sub "${AWS::StackName}-SES"
     AssumeRolePolicyDocument:
       Version: '2012-10-17'
       Statement:
         - Effect: Allow
           Principal:
             Service: lambda.amazonaws.com
           Action: sts:AssumeRole
     ManagedPolicyArns:
       - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
     Policies:
       - PolicyName: provision-ses
         PolicyDocument:
           Version: '2012-10-17'
           Statement:
             - Effect: Allow
               Action:
                 - ses:DeleteIdentity
                 - ses:GetIdentityDkimAttributes
                 - ses:GetIdentityMailFromDomainAttributes
                 - ses:GetIdentityVerificationAttributes
                 - ses:SetIdentityDomainDkim
                 - ses:SetIdentityMailFromDomain
                 - ses:VerifyDomainDkim
                 - ses:VerifyDomainIdentity
                 - ses:VerifyEmailIdentity
               Resource:
                 - "*"
             - Effect: Allow
               Action:
                 - logs:*
               Resource: arn:aws:logs:*:*:*

  SESDomainRecords:
    Type: AWS::Route53::RecordSetGroup
    Properties:
      HostedZoneName: !Sub '${EmailZoneInfo.Name}.'
      RecordSets: !GetAtt SESDomain.Route53RecordSets

  SESDomainFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "${AWS::StackName}-aws-cfn-ses-domain"
      Code:
        S3Bucket: !Ref LambdaBucket
        S3Key: lambdas/aws-cfn-ses-domain/aws-cfn-ses-domain-0.4.zip
      Handler: index.lambda_handler
      Role: !GetAtt SESDomainRole.Arn
      Runtime: python3.6
      Description: Sets up SES domain for sending email
      Timeout: 30
      MemorySize: 128
    DependsOn:
      - CopySesLambda

  SESDomain:
    Type: Custom::SES_Domain
    Properties:
      ServiceToken: !GetAtt SESDomainFunction.Arn
      Domain: !GetAtt EmailZoneInfo.Name
      EnableReceive: false
      EnableSend: true
      MailFromSubdomain: !Ref EmailSubdomain
      TTL: 1800
      CustomDMARC: '"v=DMARC1;p=reject;pct=100;aspf=r;"' # We can advise reject since we always send via SES
      Region: "us-east-1"
      EmailAddress: !Ref AdminEmailAddress

  SendEmailUser:
   Type: AWS::IAM::User
   Properties:
     UserName: !Sub "${AWS::StackName}-send-email"
     Policies:
       - PolicyName: send-email
         PolicyDocument:
           Version: '2012-10-17'
           Statement:
             - Effect: Allow
               Action:
                 - ses:SendRawEmail
               Resource: "*"
               Condition:
                 StringEquals:
                   "ses:FromAddress": !Sub "noreply@${EmailSubdomain}.${SESDomain}"
             - Effect: Allow
               Action:
                 - ses:SendRawEmail
               Resource: "*"
               Condition:
                 StringEquals:
                   "ses:FromAddress": !Sub "noreply@${SESDomain}"

  SendEmailAccessKey:
    Type: AWS::IAM::AccessKey
    DependsOn:
      - SendEmailUser
    Properties:
      UserName: !Sub "${AWS::StackName}-send-email"

  KeymasterRole:
   Type: AWS::IAM::Role
   Properties:
     RoleName: !Sub "${AWS::StackName}-KeymasterRole"
     AssumeRolePolicyDocument:
       Version: '2012-10-17'
       Statement:
         - Effect: Allow
           Principal:
             Service: lambda.amazonaws.com
           Action: sts:AssumeRole
     ManagedPolicyArns:
       - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
     Path: /
     Policies:
       - PolicyName: keymaster
         PolicyDocument:
           Version: '2012-10-17'
           Statement:
             - Effect: Allow
               Action:
                 - s3:PutObject
               Resource:
                 - !Sub '${BoxKeysBucket.Arn}/*'
             - Effect: Allow
               Action:
                 - secretsmanager:GetSecretValue
               Resource: !If
                 - IsRestore
                 - !Ref RestoreAppDbSecretArn
                 - !Sub "arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:NONE"
             - Effect: Allow
               Action:
                 - ssm:PutParameter
                 - ssm:DeleteParameter
               Resource: !Sub "arn:aws:ssm:${AWS::Region}:${AWS::AccountId}:parameter/keymaster/${AWS::StackName}/*"
             - Effect: Allow
               Action:
                 - ssm:GetParameter
               Resource: !If
                 - IsRestore
                 - !Sub "arn:aws:ssm:${RestoreStackRegion}:${AWS::AccountId}:parameter/keymaster/${RestoreStackName}/*"
                 - !Sub "arn:aws:ssm:${AWS::Region}:${AWS::AccountId}:parameter/keymaster/${AWS::StackName}/*"

  GenerateBioRingKeyFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "${AWS::StackName}-generate-bio-ring-key"
      Code:
        S3Bucket: !Ref LambdaBucket
        S3Key: lambdas/keymaster/keymaster-0.1.9.zip
      Handler: index.generate_ring_key
      Role: !GetAtt KeymasterRole.Arn
      Runtime: nodejs10.x
      Description: Generates bio ring key
      Timeout: 30
      MemorySize: 128
    DependsOn:
      - CopyKeymasterLambda

  GenerateBioServiceKeyFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "${AWS::StackName}-generate-bio-service-key"
      Code:
        S3Bucket: !Ref LambdaBucket
        S3Key: lambdas/keymaster/keymaster-0.1.9.zip
      Handler: index.generate_service_key
      Role: !GetAtt KeymasterRole.Arn
      Runtime: nodejs10.x
      Description: Generates bio service key
      Timeout: 30
      MemorySize: 128
    DependsOn:
      - CopyKeymasterLambda

  GenerateTOTPFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "${AWS::StackName}-generate-totp"
      Code:
        S3Bucket: !Ref LambdaBucket
        S3Key: lambdas/keymaster/keymaster-0.1.9.zip
      Handler: index.generate_totp
      Role: !GetAtt KeymasterRole.Arn
      Runtime: nodejs10.x
      Description: Generates ssh TOTP
      Timeout: 30
      MemorySize: 128
    DependsOn:
      - CopyKeymasterLambda

  GenerateJWTKeys:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "${AWS::StackName}-generate-jwt-keys"
      Code:
        S3Bucket: !Ref LambdaBucket
        S3Key: lambdas/keymaster/keymaster-0.1.9.zip
      Handler: index.generate_jwt_keys
      Role: !GetAtt KeymasterRole.Arn
      Runtime: nodejs10.x
      Description: Generates JWT keys
      Timeout: 30
      MemorySize: 128
    DependsOn:
      - CopyKeymasterLambda

  GenerateSecret:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "${AWS::StackName}-generate-secret"
      Code:
        S3Bucket: !Ref LambdaBucket
        S3Key: lambdas/keymaster/keymaster-0.1.9.zip
      Handler: index.generate_secret
      Role: !GetAtt KeymasterRole.Arn
      Runtime: nodejs10.x
      Description: Generate Secret Into Parameter Store
      Timeout: 30
      MemorySize: 128
    DependsOn:
      - CopyKeymasterLambda

  ReadSecret:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "${AWS::StackName}-read-secret"
      Code:
        S3Bucket: !Ref LambdaBucket
        S3Key: lambdas/keymaster/keymaster-0.1.9.zip
      Handler: index.read_secret
      Role: !GetAtt KeymasterRole.Arn
      Runtime: nodejs10.x
      Description: Reads existing AWS secrets
      Timeout: 30
      MemorySize: 128
    DependsOn:
      - CopyKeymasterLambda

  GenerateVapidKeys:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "${AWS::StackName}-generate-vapid-keys"
      Code:
        S3Bucket: !Ref LambdaBucket
        S3Key: lambdas/keymaster/keymaster-0.1.9.zip
      Handler: index.generate_vapid_keys
      Role: !GetAtt KeymasterRole.Arn
      Runtime: nodejs10.x
      Description: Generates Vapid keys
      Timeout: 30
      MemorySize: 128
    DependsOn:
      - CopyKeymasterLambda

# EmptyBucket
  EmptyBucketRole:
   Type: AWS::IAM::Role
   Properties:
     RoleName: !Sub "${AWS::StackName}-EmptyBucket"
     AssumeRolePolicyDocument:
       Version: '2012-10-17'
       Statement:
         - Effect: Allow
           Principal:
             Service: lambda.amazonaws.com
           Action: sts:AssumeRole
     ManagedPolicyArns:
       - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
     Path: /
     Policies:
       - PolicyName: delete-s3-files
         PolicyDocument:
           Version: '2012-10-17'
           Statement:
             - Effect: Allow
               Action:
                 - s3:DeleteObject
               Resource:
                 - !Sub '${AssetsBucket.Arn}/*'
                 - !Sub '${LambdaBucket.Arn}/*'
                 - !Sub '${LinkRedirectorBucket.Arn}/*'
                 - !Sub '${SpeelycaptorScratchBucket.Arn}/*'
                 - !Sub '${BoxKeysBucket.Arn}/*'
             - Effect: Allow
               Action:
                 - s3:ListBucket
               Resource:
                 - !Sub '${AssetsBucket.Arn}'
                 - !Sub '${LambdaBucket.Arn}'
                 - !Sub '${LinkRedirectorBucket.Arn}'
                 - !Sub '${BoxKeysBucket.Arn}'
                 - !Sub '${SpeelycaptorScratchBucket.Arn}'

  EmptyBucketFunction:
    Type: AWS::Lambda::Function
    Properties:
      Handler: index.handler
      Runtime: python2.7
      Role: !GetAtt EmptyBucketRole.Arn
      Timeout: 240
      Code:
        ZipFile: |
          import json
          import boto3
          from botocore.vendored import requests
          from botocore.exceptions import ClientError
          
          def handler(event, context):
              try:
                  bucket = event['ResourceProperties']['BucketName']
          
                  if event['RequestType'] == 'Delete':
                      s3 = boto3.resource('s3')

                      try: 
                          s3.meta.client.head_bucket(Bucket=bucket)
                      except ClientError:
                          # Bucket already removed/never existed
                          sendResponseCfn(event, context, "SUCCESS")
                          return

                      bucket = s3.Bucket(bucket)
                      for obj in bucket.objects.filter():
                          s3.Object(bucket.name, obj.key).delete()
          
                  sendResponseCfn(event, context, "SUCCESS")
              except Exception as e:
                  print(e)
                  sendResponseCfn(event, context, "FAILED")
          
          
          def sendResponseCfn(event, context, responseStatus):
              response_body = {'Status': responseStatus,
                               'Reason': 'Log stream name: ' + context.log_stream_name,
                               'PhysicalResourceId': context.log_stream_name,
                               'StackId': event['StackId'],
                               'RequestId': event['RequestId'],
                               'LogicalResourceId': event['LogicalResourceId'],
                               'Data': json.loads("{}")}
          
              requests.put(event['ResponseURL'], data=json.dumps(response_body))

# SESPassword
  SESPasswordRole:
   Type: AWS::IAM::Role
   Properties:
     RoleName: !Sub "${AWS::StackName}-SESPassword"
     AssumeRolePolicyDocument:
       Version: '2012-10-17'
       Statement:
         - Effect: Allow
           Principal:
             Service: lambda.amazonaws.com
           Action: sts:AssumeRole
     ManagedPolicyArns:
       - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
     Path: /
     Policies: []

  SESPasswordFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "${AWS::StackName}-ses-password"
      Handler: index.handler
      Runtime: python3.6
      Role: !GetAtt SESPasswordRole.Arn
      Timeout: 240
      Code:
        ZipFile: |
          import json
          import boto3
          import hmac
          import hashlib
          import base64
          import argparse
          from botocore.vendored import requests

          DATE = "11111111"
          SERVICE = "ses"
          MESSAGE = "SendRawEmail"
          TERMINAL = "aws4_request"
          VERSION = 0x04
          
          def sign(key, msg):
              return hmac.new(key, msg.encode('utf-8'), hashlib.sha256).digest()

          def calculateKey(secretAccessKey, region):
              signature = sign(("AWS4" + secretAccessKey).encode('utf-8'), DATE)
              signature = sign(signature, region)
              signature = sign(signature, SERVICE)
              signature = sign(signature, TERMINAL)
              signature = sign(signature, MESSAGE)
              signatureAndVersion = bytes([VERSION]) + signature
              smtpPassword = base64.b64encode(signatureAndVersion)
              return smtpPassword.decode('utf-8')

          def handler(event, context):
              try:
                  if event['RequestType'] == 'Delete':
                      sendResponseCfn(event, context, "SUCCESS", {})
                      return

                  secretAccessKey = event['ResourceProperties']['SecretAccessKey']
                  region = event['ResourceProperties']['Region']
                  key = calculateKey(secretAccessKey, region)
                  sendResponseCfn(event, context, "SUCCESS", { "Key": key })
              except Exception as e:
                  print(e)
                  sendResponseCfn(event, context, "FAILED", {})
          
          
          def sendResponseCfn(event, context, responseStatus, data):
              response_body = {'Status': responseStatus,
                               'Reason': 'Log stream name: ' + context.log_stream_name,
                               'PhysicalResourceId': context.log_stream_name,
                               'StackId': event['StackId'],
                               'RequestId': event['RequestId'],
                               'LogicalResourceId': event['LogicalResourceId'],
                               'Data': data}
          
              requests.put(event['ResponseURL'], data=json.dumps(response_body))

# CopyFile
  CopyFileRole:
   Type: AWS::IAM::Role
   Properties:
     RoleName: !Sub "${AWS::StackName}-CopyFile"
     AssumeRolePolicyDocument:
       Version: '2012-10-17'
       Statement:
         - Effect: Allow
           Principal:
             Service: lambda.amazonaws.com
           Action: sts:AssumeRole
     ManagedPolicyArns:
       - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
     Path: /
     Policies:
       - PolicyName: copy-files
         PolicyDocument:
           Version: '2012-10-17'
           Statement:
             - Effect: Allow
               Action:
                 - s3:ListBucket
                 - s3:GetObject
               Resource:
                 - arn:aws:s3:::polycosm-assets-prod-77ae26402152f4ea
                 - arn:aws:s3:::polycosm-assets-prod-77ae26402152f4ea/*
             - Effect: Allow
               Action:
                 - s3:PutObject
                 - s3:DeleteObject
               Resource:
                 - !Sub '${AssetsBucket.Arn}/*'
                 - !Sub '${LambdaBucket.Arn}/*'
                 - !Sub '${LinkRedirectorBucket.Arn}/*'

  CopyFileFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "${AWS::StackName}-copy-file"
      Handler: index.handler
      Runtime: python2.7
      Role: !GetAtt CopyFileRole.Arn
      Timeout: 240
      Code:
        ZipFile: |
          import json
          import logging
          import threading
          import boto3
          import cfnresponse
          def copy_objects(source_bucket, dest_bucket, prefix, objects):
              s3 = boto3.client('s3')
              for o in objects:
                  key = prefix + o
                  copy_source = {
                      'Bucket': source_bucket,
                      'Key': key
                  }
                  print('copy_source: %s' % copy_source)
                  print('dest_bucket = %s'%dest_bucket)
                  print('key = %s' %key)
                  s3.copy_object(CopySource=copy_source, Bucket=dest_bucket,
                        Key=key)
          def delete_objects(bucket, prefix, objects):
              s3 = boto3.client('s3')
              objects = {'Objects': [{'Key': prefix + o} for o in objects]}
              s3.delete_objects(Bucket=bucket, Delete=objects)
          def timeout(event, context):
              logging.error('Execution is about to time out, sending failure response to CloudFormation')
              cfnresponse.send(event, context, cfnresponse.FAILED, {}, None)
          def handler(event, context):
              # make sure we send a failure to CloudFormation if the function
              # is going to timeout
              timer = threading.Timer((context.get_remaining_time_in_millis()
                        / 1000.00) - 0.5, timeout, args=[event, context])
              timer.start()
              print('Received event: %s' % json.dumps(event))
              status = cfnresponse.SUCCESS
              try:
                  source_bucket = event['ResourceProperties']['SourceBucket']
                  dest_bucket = event['ResourceProperties']['DestBucket']
                  prefix = event['ResourceProperties']['Prefix']
                  objects = event['ResourceProperties']['Objects']
                  if event['RequestType'] == 'Delete':
                      delete_objects(dest_bucket, prefix, objects)
                  else:
                      copy_objects(source_bucket, dest_bucket, prefix, objects)
              except Exception as e:
                  logging.error('Exception: %s' % e, exc_info=True)
                  status = cfnresponse.FAILED
              finally:
                  timer.cancel()
                  cfnresponse.send(event, context, status, {}, None)

# StackTopicHandler
  StackTopicHandlerRole:
   Type: AWS::IAM::Role
   Properties:
     RoleName: !Sub "${AWS::StackName}-StackTopicHandler"
     AssumeRolePolicyDocument:
       Version: '2012-10-17'
       Statement:
         - Effect: Allow
           Principal:
             Service: lambda.amazonaws.com
           Action: sts:AssumeRole
     ManagedPolicyArns:
       - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
     Path: /
     Policies:
       - PolicyName: stack-topic-handler-role
         PolicyDocument:
           Version: '2012-10-17'
           Statement:
             - Effect: Allow
               Action:
                 - autoscaling:DescribeAutoScalingGroups
                 - ec2:DescribeInstances
               Resource:
                 - "*"
             - Effect: Allow
               Action: 
                 - route53:ChangeResourceRecordSets
                 - route53:ListResourceRecordSets
               Resource: !Sub "arn:aws:route53:::hostedzone/${InternalZoneInfo.Id}"
             - Effect: Allow
               Action: 
                 - route53:CreateHealthCheck
                 - route53:ListHealthChecks
                 - route53:DeleteHealthCheck
                 - route53:GetHostedZone
               Resource: "*"
             - Effect: Allow
               Action: 
                 - route53:*
               Resource: 
                 - !Sub "arn:aws:route53:::hostedzone/${InternalZoneInfo.Id}"
                 - !If [HasManagedDomain, !Sub "arn:aws:route53:::hostedzone/${ExternalZoneInfo.Id}", "arn:aws:route53:::hostedzone/DEADZONE*"]
             - Effect: Allow
               Action: 
                 - cloudformation:DescribeStacks
                 - cloudformation:GetTemplate
                 - cloudformation:UpdateStack
               Resource: !Ref "AWS::StackId"
             - Effect: Allow
               Action: 
                 - sns:ListTagsForResource
               Resource: "*"
             - Effect: Allow
               Action: 
                 - autoscaling:*
               Resource: 
                 - !Sub "arn:aws:autoscaling:${AWS::Region}:${AWS::AccountId}:autoScalingGroup:*:autoScalingGroupName/${AWS::StackName}-app"
                 - !Sub "arn:aws:autoscaling:${AWS::Region}:${AWS::AccountId}:autoScalingGroup:*:autoScalingGroupName/${AWS::StackName}-stream"
             - Effect: Allow
               Action: 
                 - elasticloadbalancing:*
               Resource: 
                 - !Sub "arn:aws:elasticloadbalancing:${AWS::Region}:${AWS::AccountId}:loadbalancer/app/${AWS::StackName}-app/*"
                 - !Sub "arn:aws:elasticloadbalancing:${AWS::Region}:${AWS::AccountId}:loadbalancer/app/${AWS::StackName}-app"
                 - !Sub "arn:aws:elasticloadbalancing:${AWS::Region}:${AWS::AccountId}:targetgroup/${AWS::StackName}-ret/*"
                 - !Sub "arn:aws:elasticloadbalancing:${AWS::Region}:${AWS::AccountId}:listener/app/${AWS::StackName}-app/*"
                 - !Sub "arn:aws:elasticloadbalancing:${AWS::Region}:${AWS::AccountId}:listener-rule/app/${AWS::StackName}-app/*"
             - Effect: Allow
               Action: 
                 - ec2:*
               Resource: 
                 - !Sub "arn:aws:ec2:${AWS::Region}:${AWS::AccountId}:security-group/*"
             - Effect: Allow
               Action: 
                 - ec2:Describe*
                 - ec2:Get*
                 - route53:Get*
                 - autoscaling:Describe*
                 - rds:Describe*
               Resource: 
                 - "*"

  # Split this policy out, so we don't block topic, ALB, and ASG creation on cloudfront
  StackTopicCloudfrontPolicy:
   Type: AWS::IAM::Policy
   Properties:
     Roles:
       - !Ref StackTopicHandlerRole
     PolicyName: !Sub "${AWS::StackName}-stack-topic-cf-policy"
     PolicyDocument:
       Version: '2012-10-17'
       Statement:
         - Effect: Allow
           Action: 
             - cloudfront:*
           Resource: !Sub "arn:aws:cloudfront::${AWS::AccountId}:distribution/${AppCloudfrontDistribution}"

  StackTopicHandler:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "${AWS::StackName}-stack-topic-handler"
      Description: Registers Node IPs into Round Robin DNS and manages stack if budgets are hit
      Handler: index.handler
      Runtime: nodejs10.x
      Role: !GetAtt StackTopicHandlerRole.Arn
      Timeout: 900
      Code:
        ZipFile: !Sub |
          const AWS=require("aws-sdk"),promisify=e=>t=>new Promise((a,n)=>e(t,(e,t)=>{e?(console.log(e),n(e)):a(t)})),OFFLINE_SETTING="Offline - Temporarily shut off servers";async function handleBudgetAlert(e,t){const a=e.Records[0].Sns.TopicArn,n=new AWS.SNS,s=(await promisify(n.listTagsForResource.bind(n))({ResourceArn:a})).Tags,r=s.find(e=>"stack-name"===e.Key).Value,o=s.find(e=>"stack-region"===e.Key).Value,i=new AWS.CloudFormation({region:o});await new Promise(async e=>{let t;const a=async()=>{const a=await promisify(i.describeStacks.bind(i))({StackName:r});if(a){const n=a.Stacks[0].StackStatus;if(n.endsWith("_COMPLETE")||n.endsWith("_FAILED"))return t&&clearInterval(t),e(),!0}return!1};await a()||(t=setInterval(a,3e4))});const c=(await promisify(i.describeStacks.bind(i))({StackName:r})).Stacks[0].Parameters,d=[];for(const e of c)"StackOffline"===e.ParameterKey?d.push({ParameterKey:e.ParameterKey,ParameterValue:OFFLINE_SETTING}):d.push({ParameterKey:e.ParameterKey,UsePreviousValue:!0});await promisify(i.updateStack.bind(i))({StackName:r,UsePreviousTemplate:!0,Parameters:d,Capabilities:["CAPABILITY_IAM","CAPABILITY_NAMED_IAM"]})}async function handleASGMessage(e,t){const a=e.AutoScalingGroupName,n=e.Event,s="${AWS::StackName}-app.${InternalZoneInfo.Name}.";if("autoscaling:EC2_INSTANCE_LAUNCH"===n||"autoscaling:EC2_INSTANCE_TERMINATE"===n){const e=new AWS.AutoScaling({region:"${AWS::Region}"}),t=new AWS.EC2({region:"${AWS::Region}"}),n=new AWS.Route53,r=await promisify(e.describeAutoScalingGroups.bind(e))({AutoScalingGroupNames:[a],MaxRecords:1}),o=(await promisify(n.listResourceRecordSets.bind(n))({StartRecordName:s,StartRecordType:"A",HostedZoneId:"${InternalZoneInfo.Id}",MaxItems:"100"})).ResourceRecordSets,i=r.AutoScalingGroups[0].Instances.map(e=>e.InstanceId),c=await promisify(t.describeInstances.bind(t))({DryRun:!1,InstanceIds:i}),d=[];for(let e=0;e<c.Reservations.length;e++){const t=c.Reservations[e];for(let e=0;e<t.Instances.length;e++){const a=t.Instances[e].NetworkInterfaces[0].Association.PublicIp;a&&d.indexOf(a)<0&&d.push(a)}}for(let e=0,t=o.length;e<t;e++){const t=o[e];if(t.Name!==s||"A"!==t.Type)continue;const a=t.ResourceRecords.length>0&&t.ResourceRecords[0].Value;if(a&&!d.find(e=>e===a))try{await promisify(n.changeResourceRecordSets.bind(n))({ChangeBatch:{Changes:[{Action:"DELETE",ResourceRecordSet:{MultiValueAnswer:!0,Name:t.Name,Type:t.Type,TTL:t.TTL,SetIdentifier:t.SetIdentifier,ResourceRecords:t.ResourceRecords,HealthCheckId:t.HealthCheckId}}]},HostedZoneId:"${InternalZoneInfo.Id}"})}catch(e){}}let l=(await promisify(n.listHealthChecks.bind(n))({MaxItems:"100"})).HealthChecks;if(d.length>1)for(let e=0,t=d.length;e<t;e++){const t=d[e];if(!l.find(e=>e.HealthCheckConfig.IPAddress===t))try{await promisify(n.createHealthCheck.bind(n))({CallerReference:Math.floor(1e9*Math.random()).toString(),HealthCheckConfig:{EnableSNI:!0,FailureThreshold:2,FullyQualifiedDomainName:s,IPAddress:t,Port:443,RequestInterval:10,ResourcePath:"/health",Type:"HTTPS"}})}catch(e){}}l=(await promisify(n.listHealthChecks.bind(n))({})).HealthChecks;for(let e=0,t=d.length;e<t;e++){const t=d[e];if(!o.find(e=>e.Name===s&&e.ResourceRecords&&e.ResourceRecords.length&&e.ResourceRecords[0].Value===t)){const e=l.find(e=>e.HealthCheckConfig.IPAddress===t);try{await promisify(n.changeResourceRecordSets.bind(n))({ChangeBatch:{Changes:[{Action:"UPSERT",ResourceRecordSet:{MultiValueAnswer:!0,Name:s,Type:"A",HealthCheckId:e?e.Id:null,TTL:15,SetIdentifier:t,ResourceRecords:[{Value:t}]}}]},HostedZoneId:"${InternalZoneInfo.Id}"})}catch(e){}}}for(let e=0,t=l.length;e<t;e++){const t=l[e];if(1===d.length||!d.find(e=>t.HealthCheckConfig.IPAddress===e))try{await promisify(n.deleteHealthCheck.bind(n))({HealthCheckId:t.Id})}catch(e){}}}else console.log("Unsupported ASG event: "+a+" "+n),t.done("Unsupported ASG event: "+a+" "+n)}exports.handler=async function(e,t){if(e.Records[0].Sns.Message.indexOf("Budget Name")>=0)return handleBudgetAlert(e,t);return handleASGMessage(JSON.parse(e.Records[0].Sns.Message),t)};
  
  InvokeStackTopicHandlerPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: 'lambda:InvokeFunction'
      FunctionName: !Ref StackTopicHandler
      Principal: sns.amazonaws.com

  StackTopicHandlerTopicPolicy:
    Type: 'AWS::SNS::TopicPolicy'
    Properties:
      Topics:
        - !Ref StackTopic
      PolicyDocument:
        Version: '2012-10-17'
        Statement: !If
          -  HasDbMonthlyBudget
          - 
            - Effect: Allow
              Sid: !Sub "${AWS::StackName}-topic-policy-stmt-asg"
              Action: 'sns:Publish'
              Resource: !Ref StackTopic
              Principal:
                AWS: "*"
              Condition:
                ArnLike:
                  AWS:SourceArn: !Ref AppASG
            - Effect: Allow
              Sid: !Sub "${AWS::StackName}-topic-policy-stmt-budget"
              Action: 'sns:Publish'
              Resource: !Ref StackTopic
              Principal:
                Service: "budgets.amazonaws.com"
          - 
            - Effect: Allow
              Sid: !Sub "${AWS::StackName}-topic-policy-stmt-asg"
              Action: 'sns:Publish'
              Resource: !Ref StackTopic
              Principal:
                AWS: "*"
              Condition:
                ArnLike:
                  AWS:SourceArn: !Ref AppASG

# EFSCreateOrRestore
  EFSCreateOrRestoreRole:
   Type: AWS::IAM::Role
   Properties:
     RoleName: !Sub "${AWS::StackName}-EFSCreateOrRestore"
     AssumeRolePolicyDocument:
       Version: '2012-10-17'
       Statement:
         - Effect: Allow
           Principal:
             Service: lambda.amazonaws.com
           Action: sts:AssumeRole
     ManagedPolicyArns:
       - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
     Path: /
     Policies:
       - PolicyName: efs-create-or-restore-role
         PolicyDocument:
           Version: '2012-10-17'
           Statement:
             - Effect: Allow
               Action:
                 - elasticfilesystem:*
                 - kms:Get*
                 - kms:Describe*
                 - kms:Decrypt
                 - backup:StartRestoreJob
                 - backup:Get*
                 - backup:Describe*
                 - backup:List*
               Resource:
                 - "*"
             - Effect: Allow
               Action:
                 - iam:PassRole
               Resource:
                 - !GetAtt DailyBackupRole.Arn

  EFSCreateOrRestore:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "${AWS::StackName}-efs-create-or-restore"
      Description: Creates or restores EFS volumes
      Handler: index.handler
      Runtime: nodejs10.x
      Role: !GetAtt EFSCreateOrRestoreRole.Arn
      Timeout: 900
      Code:
        ZipFile: !Sub |
          const https=require("https"),url=require("url"),AWS=require("aws-sdk"),promisify=e=>t=>new Promise((s,o)=>e(t,(e,t)=>{e?(console.log(e),o(e)):s(t)}));function getReason(e){return e?e.message:""}async function sendResponse(e,t,s,o,r,i){const n={StackId:t.StackId,RequestId:t.RequestId,LogicalResourceId:t.LogicalResourceId,PhysicalResourceId:e,Status:o,Reason:getReason(i)+" See details in CloudWatch Log: "+s.logStreamName,Data:r},a=JSON.stringify(n),c=url.parse(t.ResponseURL),u={hostname:c.hostname,port:443,path:c.path,method:"PUT",headers:{"content-type":"","content-length":a.length}};await new Promise((e,t)=>{const o=https.request(u,()=>{s.done(null,r),e()});o.on("error",e=>{console.log("sendResponse Error:\n",e),s.done(e),t()}),o.write(a),o.end()})}exports.handler=async function(e,t){const s=new AWS.EFS;if("Create"==e.RequestType||"Update"==e.RequestType){const o=e.ResourceProperties.PerformanceMode||"generalPurpose",r=e.ResourceProperties.ThroughputMode||"bursting",i=e.RequestId;let n=null;"provisioned"===r&&(n=e.ResourceProperties.ProvisionedThroughputInMibps);const a=e.ResourceProperties.Encrypted||!1,c=e.ResourceProperties.FileSystemTags||[],u=e.ResourceProperties.KmsKeyId||null;let d;if("Create"===e.RequestType){const l=e.ResourceProperties.RestoreBackupVaultName,p=e.ResourceProperties.RestoreRecoveryPointArn,y=e.ResourceProperties.RestoreIamRoleArn;if(p&&l){const R=new AWS.Backup,m=(await promisify(R.getRecoveryPointRestoreMetadata.bind(R))({BackupVaultName:l,RecoveryPointArn:p})).RestoreMetadata,S=(await promisify(R.startRestoreJob.bind(R))({RecoveryPointArn:p,Metadata:{"file-system-id":m["file-system-id"],PerformanceMode:o,CreationToken:i,Encrypted:a?"true":"false",KmsKeyId:u,newFileSystem:"true"},ResourceType:"EFS",IdempotencyToken:i,IamRoleArn:y})).RestoreJobId,I=await new Promise(async(s,o)=>{let r;const i=async()=>{const i=await promisify(R.describeRestoreJob.bind(R))({RestoreJobId:S});return("COMPLETED"===i.Status||"FAILED"===i.Status)&&(r&&clearInterval(r),"COMPLETED"===i.Status?s(i.CreatedResourceArn):(await sendResponse(null,e,t,"FAILED",{},"Restore job failed."),o()),!0)};await i()||(r=setInterval(i,1e4))});d=I.split("/")[1],await promisify(s.createTags.bind(s))({FileSystemId:d,Tags:c}),"bursting"!==r&&await promisify(s.updateFileSystem.bind(s))({FileSystemId:d,ThroughputMode:r,ProvisionedThroughputInMibps:n})}else d=(await promisify(s.createFileSystem.bind(s))({PerformanceMode:o,CreationToken:i,ThroughputMode:r,Encrypted:a,Tags:c,KmsKeyId:u,ProvisionedThroughputInMibps:n})).FileSystemId}else d=e.PhysicalResourceId,await promisify(s.updateFileSystem.bind(s))({FileSystemId:d,ThroughputMode:r,ProvisionedThroughputInMibps:n});await new Promise(async e=>{let t;const o=async()=>{return"available"===(await promisify(s.describeFileSystems.bind(s))({FileSystemId:d})).FileSystems[0].LifeCycleState&&(t&&clearInterval(t),e(),!0)};await o()||(t=setInterval(o,1e4))});const l=e.ResourceProperties.LifecyclePolicies;return l&&await promisify(s.putLifecycleConfiguration.bind(s))({FileSystemId:d,LifecyclePolicies:l}),void await sendResponse(d,e,t,"SUCCESS")}if("Delete"==e.RequestType){const o=e.PhysicalResourceId;return await promisify(s.deleteFileSystem.bind(s))({FileSystemId:o}),void await sendResponse(o,e,t,"SUCCESS")}};

  LambdaBucket:
    Type: AWS::S3::Bucket
    Properties:
      AccessControl: Private
      BucketName: !Join ["-", [ !Sub "${AWS::StackName}-lambdas", !Select [0, !Split [ "-", !Select [2, !Split ["/", !Ref "AWS::StackId"]]]]]]
  EmptyLambdaBucket:
    Type: Custom::EmptyLambdaBucket
    Properties:
      ServiceToken: !GetAtt EmptyBucketFunction.Arn
      BucketName: !Ref LambdaBucket
    DependsOn:
      - EmptyBucketRole
  SendEmailPassword:
    Type: Custom::SendEmailPassword
    Properties:
      ServiceToken: !GetAtt SESPasswordFunction.Arn
      SecretAccessKey: !GetAtt SendEmailAccessKey.SecretAccessKey
      Region: "us-east-1"
    DependsOn:
      - SendEmailUser
  BoxKeysBucket:
    Type: AWS::S3::Bucket
    Properties:
      AccessControl: Private
      BucketName: !Join ["-", [ !Sub "${AWS::StackName}-box-keys", !Select [0, !Split [ "-", !Select [2, !Split ["/", !Ref "AWS::StackId"]]]]]]
  EmptyBoxKeysBucket:
    Type: Custom::EmptyBoxKeysBucket
    Properties:
      ServiceToken: !GetAtt EmptyBucketFunction.Arn
      BucketName: !Ref BoxKeysBucket
    DependsOn:
      - EmptyBucketRole

# SSH TOTP
  SshTOTP:
    Type: Custom::SshTOTP
    Properties:
      ServiceToken: !GetAtt GenerateTOTPFunction.Arn
      BucketName: !Ref BoxKeysBucket
      BucketRegion: !Ref "AWS::Region"
      StackName: !Ref "AWS::StackName"

# JWT Keys
  JWTKeys:
    Type: Custom::JWTKeys
    Properties:
      ServiceToken: !GetAtt GenerateJWTKeys.Arn
      BucketName: !Ref BoxKeysBucket
      BucketRegion: !Ref "AWS::Region"

# Vapid Keys
  VapidKeys:
    Type: Custom::VapidKeys
    Properties:
      ServiceToken: !GetAtt GenerateVapidKeys.Arn
      BucketName: !Ref BoxKeysBucket
      BucketRegion: !Ref "AWS::Region"

# Bio Keys
  BioRingKey:
    Type: Custom::BioRingKey
    Properties:
      ServiceToken: !GetAtt GenerateBioRingKeyFunction.Arn
      BucketName: !Ref BoxKeysBucket
      BucketRegion: !Ref "AWS::Region"
      KeyName: !Ref "AWS::StackName"

  BioReticulumServiceKey:
    Type: Custom::BioReticulumServiceKey
    Properties:
      ServiceToken: !GetAtt GenerateBioServiceKeyFunction.Arn
      BucketName: !Ref BoxKeysBucket
      BucketRegion: !Ref "AWS::Region"
      ServiceName: "reticulum.default"
      Org: !Ref "AWS::StackName"

  BioJanusServiceKey:
    Type: Custom::BioJanusServiceKey
    Properties:
      ServiceToken: !GetAtt GenerateBioServiceKeyFunction.Arn
      BucketName: !Ref BoxKeysBucket
      BucketRegion: !Ref "AWS::Region"
      ServiceName: "janus-gateway.default"
      Org: !Ref "AWS::StackName"

  BioPostgrestServiceKey:
    Type: Custom::BioPostgrestServiceKey
    Properties:
      ServiceToken: !GetAtt GenerateBioServiceKeyFunction.Arn
      BucketName: !Ref BoxKeysBucket
      BucketRegion: !Ref "AWS::Region"
      ServiceName: "postgrest.default"
      Org: !Ref "AWS::StackName"

  BioYTDLServiceKey:
    Type: Custom::BioYTDLServiceKey
    Properties:
      ServiceToken: !GetAtt GenerateBioServiceKeyFunction.Arn
      BucketName: !Ref BoxKeysBucket
      BucketRegion: !Ref "AWS::Region"
      ServiceName: "youtube-dl-api-server.default"
      Org: !Ref "AWS::StackName"

# Speelycaptor
  SpeelycaptorInitLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub "/aws/lambda/${AWS::StackName}-speelycaptor-initialize"
  SpeelycaptorConvertLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub "/aws/lambda/${AWS::StackName}-speelycaptor-convert"
  SpeelycaptorScratchBucket:
    Type: AWS::S3::Bucket
    Properties:
      AccessControl: Private
      BucketName: !Join ["-", [ !Sub "${AWS::StackName}-speelycaptor-scratch", !Select [0, !Split [ "-", !Select [2, !Split ["/", !Ref "AWS::StackId"]]]]]]
  EmptySpeelycaptorScratchBucket:
    Type: Custom::EmptySpeelycaptorScratchBucket
    Properties:
      ServiceToken: !GetAtt EmptyBucketFunction.Arn
      BucketName: !Ref SpeelycaptorScratchBucket
    DependsOn:
      - EmptyBucketRole
  SpeelycaptorRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "${AWS::StackName}-Speelycaptor"
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Service:
            - lambda.amazonaws.com
          Action:
          - sts:AssumeRole
          Sid: ""
      Path: "/"
  SpeelycaptorRolePolicy:
    Type: AWS::IAM::Policy
    Properties:
      PolicyName: "speelycaptor-policy"
      Roles:
        - !Ref SpeelycaptorRole
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Action: s3:GetObject
            Resource: !Sub "${SpeelycaptorScratchBucket.Arn}/*"
          - Effect: Allow
            Action: s3:PutObject
            Resource: !Sub "${SpeelycaptorScratchBucket.Arn}/*"
          - Effect: Allow
            Action: s3:PutObjectAcl
            Resource: !Sub "${SpeelycaptorScratchBucket.Arn}/*"
          - Effect: Allow
            Action: s3:GetObject
            Resource: !Sub "${SpeelycaptorScratchBucket.Arn}/*"
          - Effect: Allow
            Action: s3:ListBucket
            Resource: !Sub "${SpeelycaptorScratchBucket.Arn}"
          - Effect: Allow
            Action: 
              - ec2:DescribeInstances
              - ec2:CreateNetworkInterface
              - ec2:AttachNetworkInterface
              - ec2:DescribeNetworkInterfaces
              - ec2:DeleteNetworkInterface
              - autoscaling:CompleteLifecycleAction
            Resource: "*"
          - Effect: Allow
            Action:
              - logs:CreateLogGroup
              - logs:CreateLogStream
              - logs:PutLogEvents
            Resource: !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/*:*:*"
  SpeelycaptorInitLambdaFunction:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        S3Bucket: !Ref LambdaBucket
        S3Key: lambdas/speelycaptor/speelycaptor-0.1.2.zip
      FunctionName: !Sub "${AWS::StackName}-speelycaptor-initialize"
      Handler: index.init
      MemorySize: 1024
      Role: !GetAtt SpeelycaptorRole.Arn
      Runtime: nodejs10.x
      Timeout: 120
      Environment:
        Variables:
          scratchBucketRegion: !Ref "AWS::Region"
          scratchBucketId: !Ref SpeelycaptorScratchBucket
    DependsOn:
      - SpeelycaptorInitLogGroup
      - CopySpeelycaptorLambda
  SpeelycaptorConvertLambdaFunction:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        S3Bucket: !Ref LambdaBucket
        S3Key: lambdas/speelycaptor/speelycaptor-0.1.2.zip
      FunctionName: !Sub "${AWS::StackName}-speelycaptor-convert"
      Handler: index.convert
      MemorySize: 3000
      Role: !GetAtt SpeelycaptorRole.Arn
      Runtime: nodejs10.x
      Timeout: 120
      Environment:
        Variables:
          scratchBucketRegion: !Ref "AWS::Region"
          scratchBucketId: !Ref SpeelycaptorScratchBucket
    DependsOn:
      - SpeelycaptorConvertLogGroup
      - CopySpeelycaptorLambda
  SpeelycaptorApiGatewayRestApi:
    Type: AWS::ApiGateway::RestApi
    Properties:
      Name: speelycaptor
      EndpointConfiguration:
        Types:
          - EDGE
  SpeelycaptorApiGatewayResourceInit:
    Type: AWS::ApiGateway::Resource
    Properties:
      ParentId: !GetAtt SpeelycaptorApiGatewayRestApi.RootResourceId
      PathPart: init
      RestApiId: !Ref SpeelycaptorApiGatewayRestApi
  SpeelycaptorApiGatewayResourceConvert:
    Type: AWS::ApiGateway::Resource
    Properties:
      ParentId: !GetAtt SpeelycaptorApiGatewayRestApi.RootResourceId
      PathPart: convert
      RestApiId: !Ref SpeelycaptorApiGatewayRestApi
  SpeelycaptorApiGatewayMethodInitGet:
    Type: AWS::ApiGateway::Method
    Properties:
      HttpMethod: GET
      ResourceId: !Ref SpeelycaptorApiGatewayResourceInit
      RestApiId: !Ref SpeelycaptorApiGatewayRestApi
      ApiKeyRequired: false
      AuthorizationType: NONE
      Integration:
        IntegrationHttpMethod: POST
        Type: AWS_PROXY
        Uri: !Sub 'arn:${AWS::Partition}:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${SpeelycaptorInitLambdaFunction.Arn}/invocations'
      MethodResponses: []
  SpeelycaptorApiGatewayMethodConvertGet:
    Type: AWS::ApiGateway::Method
    Properties:
      HttpMethod: GET
      ResourceId: !Ref SpeelycaptorApiGatewayResourceConvert
      RestApiId: !Ref SpeelycaptorApiGatewayRestApi
      ApiKeyRequired: false
      AuthorizationType: NONE
      Integration:
        IntegrationHttpMethod: POST
        Type: AWS_PROXY
        Uri: !Sub 'arn:${AWS::Partition}:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${SpeelycaptorConvertLambdaFunction.Arn}/invocations'
      MethodResponses: []
  SpeelycaptorApiGatewayDeployment:
    Type: AWS::ApiGateway::Deployment
    Properties:
      RestApiId: !Ref SpeelycaptorApiGatewayRestApi
      StageName: prod
    DependsOn:
      - SpeelycaptorApiGatewayMethodInitGet
      - SpeelycaptorApiGatewayMethodConvertGet
  SpeelycaptorInitLambdaPermissionApiGateway:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !GetAtt SpeelycaptorInitLambdaFunction.Arn
      Action: lambda:InvokeFunction
      Principal: !Sub 'apigateway.${AWS::URLSuffix}'
      SourceArn: !Sub 'arn:${AWS::Partition}:execute-api:${AWS::Region}:${AWS::AccountId}:${SpeelycaptorApiGatewayRestApi}/*/*'
  SpeelycaptorConvertLambdaPermissionApiGateway:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !GetAtt SpeelycaptorConvertLambdaFunction.Arn
      Action: lambda:InvokeFunction
      Principal: !Sub 'apigateway.${AWS::URLSuffix}'
      SourceArn: !Sub 'arn:${AWS::Partition}:execute-api:${AWS::Region}:${AWS::AccountId}:${SpeelycaptorApiGatewayRestApi}/*/*'

# Photomnemonic
  PhotomnemonicRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "${AWS::StackName}-Photomnemonic"
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Service:
            - lambda.amazonaws.com
          Action:
          - sts:AssumeRole
          Sid: ""
      Path: "/"
  PhotomnemonicScreenshotLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub "/aws/lambda/${AWS::StackName}-photomnemonic-screenshot"
  PhotomnemonicRolePolicy:
    Type: AWS::IAM::Policy
    Properties:
      PolicyName: "photomnemonic-policy"
      Roles:
        - !Ref PhotomnemonicRole
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Action: 
              - ec2:DescribeInstances
              - ec2:CreateNetworkInterface
              - ec2:AttachNetworkInterface
              - ec2:DescribeNetworkInterfaces
              - ec2:DeleteNetworkInterface
              - autoscaling:CompleteLifecycleAction
            Resource: "*"
          - Effect: Allow
            Action:
              - logs:CreateLogGroup
              - logs:CreateLogStream
              - logs:PutLogEvents
            Resource: !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/*:*:*"
  PhotomnemonicScreenshotLambdaFunction:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        S3Bucket: !Ref LambdaBucket
        S3Key: lambdas/photomnemonic/photomnemonic-0.1.0.zip
      FunctionName: !Sub "${AWS::StackName}-photomnemonic-screenshot"
      Handler: index.handler
      MemorySize: 1024
      Role: !GetAtt PhotomnemonicRole.Arn
      Runtime: nodejs10.x
      Timeout: 30
    DependsOn:
      - CopyPhotomnemonicLambda
      - PhotomnemonicScreenshotLogGroup
  PhotomnemonicApiGatewayRestApi:
    Type: AWS::ApiGateway::RestApi
    Properties:
      Name: photomnemonic
      BinaryMediaTypes:
        - "*/*"
      EndpointConfiguration:
        Types:
          - EDGE
      Body:
        swagger: 2.0
        paths:
          "/screenshot":
            get:
              parameters:
                - name: url
                  in: query
                  required: true
              x-amazon-apigateway-binary-media-types:
                - "*/*"
              x-amazon-apigateway-integration:
                httpMethod: POST
                responses:
                  contentHandling: CONVERT_TO_BINARY,
                type: aws_proxy
                contentHandling: CONVERT_TO_BINARY
                uri:
                  Fn::Sub: arn:${AWS::Partition}:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PhotomnemonicScreenshotLambdaFunction.Arn}/invocations
  PhotomnemonicApiGatewayDeployment:
    Type: AWS::ApiGateway::Deployment
    Properties:
      RestApiId: !Ref PhotomnemonicApiGatewayRestApi
      StageName: prod
    DependsOn:
      - PhotomnemonicApiGatewayRestApi
  PhotomnemonicScreenshotLambdaPermissionApiGateway:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !GetAtt PhotomnemonicScreenshotLambdaFunction.Arn
      Action: lambda:InvokeFunction
      Principal: !Sub 'apigateway.${AWS::URLSuffix}'
      SourceArn: !Sub 'arn:${AWS::Partition}:execute-api:${AWS::Region}:${AWS::AccountId}:${PhotomnemonicApiGatewayRestApi}/*/*'

# Nearspark
  NearsparkRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "${AWS::StackName}-Nearspark"
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Service:
            - lambda.amazonaws.com
          Action:
          - sts:AssumeRole
          Sid: ""
      Path: "/"
  NearsparkThumbnailLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub "/aws/lambda/${AWS::StackName}-nearspark-thumbnail"
  NearsparkRolePolicy:
    Type: AWS::IAM::Policy
    Properties:
      PolicyName: "nearspark-policy"
      Roles:
        - !Ref NearsparkRole
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Action: 
              - ec2:DescribeInstances
              - ec2:CreateNetworkInterface
              - ec2:AttachNetworkInterface
              - ec2:DescribeNetworkInterfaces
              - ec2:DeleteNetworkInterface
              - autoscaling:CompleteLifecycleAction
            Resource: "*"
          - Effect: Allow
            Action:
              - logs:CreateLogGroup
              - logs:CreateLogStream
              - logs:PutLogEvents
            Resource: !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/*:*:*"
  NearsparkThumbnailLambdaFunction:
    Type: AWS::Lambda::Function
    Properties:
      Description: Generates resized thumbnails
      Code:
        S3Bucket: !Ref LambdaBucket
        S3Key: lambdas/nearspark/nearspark-0.1.0.zip
      FunctionName: !Sub "${AWS::StackName}-nearspark-thumbnail"
      Handler: index.handler
      MemorySize: 128
      Role: !GetAtt NearsparkRole.Arn
      Runtime: nodejs10.x
      Timeout: 600
    DependsOn:
      - CopyNearsparkLambda
      - NearsparkThumbnailLogGroup
  NearsparkApiGatewayRestApi:
    Type: AWS::ApiGateway::RestApi
    Properties:
      Name: nearspark
      BinaryMediaTypes:
        - "*/*"
      EndpointConfiguration:
        Types:
          - EDGE
      Body:
        swagger: 2.0
        paths:
          "/thumbnail/{url}":
            get:
              consumes:
                - "application/json"
              parameters:
                - name: url
                  in: path
                  required: true
                  type: string
                - name: width
                  in: query
                  required: true
                  type: number
                - name: height
                  in: query
                  required: true
                  type: number
                - name: fit
                  in: query
                  required: false
                  type: string
                - name: position
                  in: query
                  required: false
                  type: string
                - name: gravity
                  in: query
                  required: false
                  type: string
                - name: strategy
                  in: query
                  required: false
                  type: string
                - name: background
                  in: query
                  required: false
                  type: string
                - name: withoutEnlargement
                  in: query
                  required: false
                  type: boolean
              requestTemplates:
                "application/json": "{\"url\": \"$input.params('url')\"}"
              x-amazon-apigateway-binary-media-types:
                - "*/*"
              x-amazon-apigateway-integration:
                httpMethod: POST
                responses:
                  contentHandling: CONVERT_TO_BINARY,
                type: aws_proxy
                contentHandling: CONVERT_TO_BINARY
                uri:
                  Fn::Sub: arn:${AWS::Partition}:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${NearsparkThumbnailLambdaFunction.Arn}/invocations
  NearsparkApiGatewayDeployment:
    Type: AWS::ApiGateway::Deployment
    Properties:
      RestApiId: !Ref NearsparkApiGatewayRestApi
      StageName: prod
    DependsOn:
      - NearsparkApiGatewayRestApi

  NearsparkThumbnailLambdaPermissionApiGateway:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !GetAtt NearsparkThumbnailLambdaFunction.Arn
      Action: lambda:InvokeFunction
      Principal: !Sub 'apigateway.${AWS::URLSuffix}'
      SourceArn: !Sub 'arn:${AWS::Partition}:execute-api:${AWS::Region}:${AWS::AccountId}:${NearsparkApiGatewayRestApi}/*/*'

  NearsparkDNS:
    Type: AWS::Route53::RecordSet
    Properties:
      Name: !Sub '${AWS::StackName}-nearspark.${InternalZoneInfo.Name}'
      HostedZoneId: !Ref InternalZone
      Type: A
      AliasTarget:
        DNSName:
          Fn::GetAtt: [ NearsparkCloudfrontDistribution, DomainName ]
        HostedZoneId: Z2FDTNDATAQYW2

  NearsparkCloudfrontDistribution:
    Type: AWS::CloudFront::Distribution
    Properties:
      DistributionConfig:
        Origins:
          - Id: ApiGateway
            DomainName: !Sub '${NearsparkApiGatewayRestApi}.execute-api.${AWS::Region}.amazonaws.com'
            CustomOriginConfig:
              HTTPPort: 80
              HTTPSPort: 443
              OriginProtocolPolicy: https-only
              OriginSSLProtocols: [ "SSLv3", "TLSv1", "TLSv1.1", "TLSv1.2" ]
            OriginPath: "/prod"
        Enabled: true
        HttpVersion: http2
        PriceClass: PriceClass_All
        Aliases:
          - !Sub '${AWS::StackName}-nearspark.${InternalZoneInfo.Name}'
        DefaultCacheBehavior:
          AllowedMethods:
            - GET
            - HEAD
            - OPTIONS
          CachedMethods:
            - GET
            - HEAD
          TargetOriginId: ApiGateway
          ForwardedValues:
            QueryString: true
            Headers: []
            Cookies:
              Forward: none
          ViewerProtocolPolicy: redirect-to-https
          MinTTL: '0'
          DefaultTTL: '3600'
        ViewerCertificate:
          AcmCertificateArn: !Ref InternalZoneSSLCertEast
          SslSupportMethod: sni-only

  AssetsBucket:
    Type: AWS::S3::Bucket
    Properties:
      AccessControl: PublicRead
      BucketName: !Join ["-", [ !Sub "${AWS::StackName}-assets", !Select [0, !Split [ "-", !Select [2, !Split ["/", !Ref "AWS::StackId"]]]]]]
      CorsConfiguration:
        CorsRules:
          - AllowedHeaders:
              - "*"
            AllowedMethods:
              - GET
              - HEAD
            AllowedOrigins:
              - !Sub "https://${DomainName}"
              - !Sub "https://${ShortlinkZoneInfo.Name}"
            ExposedHeaders: []
            MaxAge: 31536000
  AssetsPublicBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      PolicyDocument:
        Id: PublicAssets
        Version: 2012-10-17
        Statement:
          - Sid: PublicReadForGetBucketObjects
            Effect: Allow
            Principal: '*'
            Action: 's3:GetObject'
            Resource: !Sub '${AssetsBucket.Arn}/*'
      Bucket: !Ref AssetsBucket
  EmptyAssetsBucket:
    Type: Custom::EmptyAssetsBucket
    Properties:
      ServiceToken: !GetAtt EmptyBucketFunction.Arn
      BucketName: !Ref AssetsBucket
    DependsOn:
      - EmptyBucketRole
  CopyPDFJSAssets:
    Type: Custom::CopyPDFJSAssets
    UpdateReplacePolicy: Retain
    DependsOn: AssetsBucket
    Properties:
      ServiceToken: !GetAtt CopyFileFunction.Arn
      DestBucket: !Ref AssetsBucket
      SourceBucket: polycosm-assets-prod-77ae26402152f4ea
      Prefix: ""
      Objects:
        - assets/js/pdfjs-dist@2.1.266/build/pdf.worker.js

  RootRedirectorBucket:
    Type: AWS::S3::Bucket
    Properties:
      AccessControl: PublicRead
      BucketName: !Join ["-", [ !Sub "${AWS::StackName}-root-redirector", !Select [0, !Split [ "-", !Select [2, !Split ["/", !Ref "AWS::StackId"]]]]]]
      CorsConfiguration:
        CorsRules:
          - AllowedHeaders:
            - "*"
            AllowedMethods:
            - GET
            - HEAD
            AllowedOrigins:
            - "*"
            ExposedHeaders:
            - Date
            - ETag
            MaxAge: 31536000
      WebsiteConfiguration:
        IndexDocument: index.html
        ErrorDocument: error.html
        RoutingRules:
          - RedirectRule:
              ReplaceKeyPrefixWith: !GetAtt ParsedOfflineRedirectUrl.S3ReplaceKeyPrefixWith
              Protocol: !GetAtt ParsedOfflineRedirectUrl.S3Protocol
              HostName: !GetAtt ParsedOfflineRedirectUrl.S3Hostname
              HttpRedirectCode: 307

  LinkRedirectorBucket:
    Type: AWS::S3::Bucket
    Properties:
      AccessControl: PublicRead
      BucketName: !Join ["-", [ !Sub "${AWS::StackName}-link-redirector", !Select [0, !Split [ "-", !Select [2, !Split ["/", !Ref "AWS::StackId"]]]]]]
      CorsConfiguration:
        CorsRules:
          - AllowedHeaders:
            - "*"
            AllowedMethods:
            - GET
            - HEAD
            AllowedOrigins:
            - "*"
            ExposedHeaders:
            - Date
            - ETag
            MaxAge: 31536000
      WebsiteConfiguration:
        IndexDocument: link-redirector-index.html
        ErrorDocument: link-redirector-error.html
        RoutingRules:
          - RedirectRule:
              ReplaceKeyPrefixWith: "link/"
              Protocol: https
              HostName: !Ref DomainName
  EmptyLinkRedirectorBucket:
    Type: Custom::EmptyLinkRedirectorBucket
    Properties:
      ServiceToken: !GetAtt EmptyBucketFunction.Arn
      BucketName: !Ref LinkRedirectorBucket
    DependsOn:
      - EmptyBucketRole
  LinkRedirectorPublicBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      PolicyDocument:
        Id: PublicLinkRedirector
        Version: 2012-10-17
        Statement:
          - Sid: PublicReadForGetBucketObjects
            Effect: Allow
            Principal: '*'
            Action: 's3:GetObject'
            Resource: !Sub '${LinkRedirectorBucket.Arn}/*'
      Bucket: !Ref LinkRedirectorBucket
  CopyLinkRedirectorIndex:
    Type: Custom::CopyLinkRedirectorIndex
    UpdateReplacePolicy: Retain
    DependsOn: LinkRedirectorBucket
    Properties:
      ServiceToken: !GetAtt CopyFileFunction.Arn
      DestBucket: !Ref LinkRedirectorBucket
      SourceBucket: polycosm-assets-prod-77ae26402152f4ea
      Prefix: ""
      Objects:
        - link-redirector-index.html
        - link-redirector-error.html
  LinkRedirectorDNS:
    Type: AWS::Route53::RecordSet
    Properties:
      Name: !GetAtt ShortlinkZoneInfo.Name
      HostedZoneId: !Ref ShortlinkZone
      Type: A
      AliasTarget:
        DNSName:
          Fn::GetAtt: [ LinkRedirectorCloudfrontDistribution, DomainName ]
        HostedZoneId: Z2FDTNDATAQYW2

  LinkRedirectorCloudfrontDistribution:
    Type: AWS::CloudFront::Distribution
    Properties:
      DistributionConfig:
        Origins:
          - Id: !Sub "${AWS::StackName}-link-redirector"
            DomainName: !Select [2, !Split ["/", !GetAtt LinkRedirectorBucket.WebsiteURL]]
            CustomOriginConfig:
              HTTPPort: 80
              HTTPSPort: 443
              OriginProtocolPolicy: http-only
              OriginSSLProtocols: [ "SSLv3", "TLSv1", "TLSv1.1", "TLSv1.2" ]
        Enabled: true
        PriceClass: PriceClass_All
        Aliases:
          - !GetAtt ShortlinkZoneInfo.Name
        DefaultCacheBehavior:
          AllowedMethods:
            - GET
            - HEAD
            - OPTIONS
          CachedMethods:
            - GET
            - HEAD
          TargetOriginId: !Sub "${AWS::StackName}-link-redirector"
          ForwardedValues:
            QueryString: false
            Headers: []
            Cookies:
              Forward: none
          ViewerProtocolPolicy: allow-all
          MinTTL: 86400
          DefaultTTL: 86400
          MaxTTL: 86400
        Restrictions:
          GeoRestriction:
            RestrictionType: none
            Locations: []
        ViewerCertificate:
          AcmCertificateArn: !Ref ShortlinkZoneSSLCertEast
          SslSupportMethod: sni-only
          MinimumProtocolVersion: "TLSv1"

# App servers
  AppALBSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Condition: HasALB
    Properties:
      GroupName: !Sub "${AWS::StackName}-app-alb"
      GroupDescription: App ALB
      VpcId: !Ref VPC
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 80
          ToPort: 80
          CidrIp: 0.0.0.0/0
        - IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          CidrIp: 0.0.0.0/0

  BioRingSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupName: !Sub "${AWS::StackName}-bio-ring"
      GroupDescription: Bio
      VpcId: !Ref VPC

  BioRingRPCIngress:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      GroupId: !Ref BioRingSecurityGroup
      IpProtocol: tcp
      FromPort: 9638
      ToPort: 9638
      SourceSecurityGroupId: !Ref BioRingSecurityGroup

  BioRingRPCEgress:
    Type: AWS::EC2::SecurityGroupEgress
    Properties:
      GroupId: !Ref BioRingSecurityGroup
      IpProtocol: tcp
      FromPort: 9638
      ToPort: 9638
      DestinationSecurityGroupId: !Ref BioRingSecurityGroup

  BioRingRPCUDPIngress:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      GroupId: !Ref BioRingSecurityGroup
      IpProtocol: udp
      FromPort: 9638
      ToPort: 9638
      SourceSecurityGroupId: !Ref BioRingSecurityGroup

  BioRingRPCUDPEgress:
    Type: AWS::EC2::SecurityGroupEgress
    Properties:
      GroupId: !Ref BioRingSecurityGroup
      IpProtocol: udp
      FromPort: 9638
      ToPort: 9638
      DestinationSecurityGroupId: !Ref BioRingSecurityGroup

  AppSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupName: !Sub "${AWS::StackName}-app"
      GroupDescription: App
      VpcId: !Ref VPC
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: !FindInMap [ServicesMeta, RetExternal, Port]
          ToPort: !FindInMap [ServicesMeta, RetExternal, Port]
          CidrIp: 0.0.0.0/0
        - IpProtocol: tcp
          FromPort: !FindInMap [ServicesMeta, JanusExternal, Port]
          ToPort: !FindInMap [ServicesMeta, JanusExternal, Port]
          CidrIp: 0.0.0.0/0
        - IpProtocol: udp
          FromPort: !FindInMap [ServicesMeta, JanusWebRTCFrom, Port]
          ToPort: !FindInMap [ServicesMeta, JanusWebRTCTo, Port]
          CidrIp: 0.0.0.0/0
        - IpProtocol: tcp
          FromPort: !FindInMap [ServicesMeta, JanusWebRTCFrom, Port]
          ToPort: !FindInMap [ServicesMeta, JanusWebRTCTo, Port]
          CidrIp: 0.0.0.0/0
        - IpProtocol: tcp
          FromPort: !FindInMap [ServicesMeta, Ssh, Port]
          ToPort: !FindInMap [ServicesMeta, Ssh, Port]
          CidrIp: 0.0.0.0/0
      SecurityGroupEgress:
        # Outbound HTTP
        - IpProtocol: tcp
          FromPort: 80
          ToPort: 80
          CidrIp: 0.0.0.0/0
        # Outbound HTTPS
        - IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          CidrIp: 0.0.0.0/0
        # Outbound SMTP
        - IpProtocol: tcp
          FromPort: 587
          ToPort: 587
          CidrIp: 0.0.0.0/0
        # Outbound NTP
        - IpProtocol: tcp
          FromPort: 123
          ToPort: 123
          CidrIp: 0.0.0.0/0
        # Outbound RTP
        - IpProtocol: udp
          FromPort: 0
          ToPort: 65535
          CidrIp: 0.0.0.0/0
        # Outbound DNS
        - IpProtocol: tcp
          FromPort: 53
          ToPort: 53
          CidrIp: 0.0.0.0/0

  AppALBReticulumIngress:
    Type: AWS::EC2::SecurityGroupIngress
    Condition: HasALB
    Properties:
      GroupId: !Ref AppSecurityGroup
      IpProtocol: tcp
      FromPort: !FindInMap [ServicesMeta, RetInternal, Port]
      ToPort: !FindInMap [ServicesMeta, RetInternal, Port]
      SourceSecurityGroupId: !Ref AppALBSecurityGroup

  AppALBReticulumEgress:
    Type: AWS::EC2::SecurityGroupEgress
    Condition: HasALB
    Properties:
      GroupId: !Ref AppALBSecurityGroup
      IpProtocol: tcp
      FromPort: !FindInMap [ServicesMeta, RetInternal, Port]
      ToPort: !FindInMap [ServicesMeta, RetInternal, Port]
      DestinationSecurityGroupId: !Ref AppSecurityGroup

  AppJanusAdminAppIngress:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      GroupId: !Ref AppSecurityGroup
      IpProtocol: tcp
      FromPort: !FindInMap [ServicesMeta, JanusAdmin, Port]
      ToPort: !FindInMap [ServicesMeta, JanusAdmin, Port]
      SourceSecurityGroupId: !Ref AppSecurityGroup

  AppJanusAdminStreamEgress:
    Type: AWS::EC2::SecurityGroupEgress
    Properties:
      GroupId: !Ref AppSecurityGroup
      IpProtocol: tcp
      FromPort: !FindInMap [ServicesMeta, JanusAdmin, Port]
      ToPort: !FindInMap [ServicesMeta, JanusAdmin, Port]
      DestinationSecurityGroupId: !Ref StreamSecurityGroup

  AppEPMDAppIngress:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      GroupId: !Ref AppSecurityGroup
      IpProtocol: tcp
      FromPort: 4369
      ToPort: 4369
      SourceSecurityGroupId: !Ref AppSecurityGroup

  AppErlangAppIngress:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      GroupId: !Ref AppSecurityGroup
      IpProtocol: tcp
      FromPort: 9000
      ToPort: 9100
      SourceSecurityGroupId: !Ref AppSecurityGroup

  AppDbEgress:
    Type: AWS::EC2::SecurityGroupEgress
    Properties:
      GroupId: !Ref AppSecurityGroup
      IpProtocol: tcp
      ToPort: !FindInMap [ServicesMeta, PostgreSQL, Port]
      FromPort: !FindInMap [ServicesMeta, PostgreSQL, Port]
      DestinationSecurityGroupId: !Ref AppDbSecurityGroup

  AppFullSelfEgress:
    Type: AWS::EC2::SecurityGroupEgress
    Properties:
      GroupId: !Ref AppSecurityGroup
      IpProtocol: tcp
      FromPort: 0
      ToPort: 65535
      DestinationSecurityGroupId: !Ref AppSecurityGroup

  AppRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "${AWS::StackName}-app"
      AssumeRolePolicyDocument:
        Statement:
          - Action:
              - sts:AssumeRole
            Effect: Allow
            Principal:
              Service: ec2.amazonaws.com
        Version: '2012-10-17'
      ManagedPolicyArns:
        - !Ref BasePolicy

  StreamRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "${AWS::StackName}-stream"
      AssumeRolePolicyDocument:
        Statement:
          - Action:
              - sts:AssumeRole
            Effect: Allow
            Principal:
              Service: ec2.amazonaws.com
        Version: '2012-10-17'
      ManagedPolicyArns:
        - !Ref BasePolicy

  BasePolicy:
    Type: AWS::IAM::ManagedPolicy
    Properties:
      PolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Action: 
              - ec2:DescribeInstances
            Resource: "*"
          - Effect: Allow
            Action: 
              - ec2:CreateTags
            Resource: "*"
          - Effect: Allow
            Action: 
              - ec2:DescribeTags
            Resource: "*"
          - Effect: Allow
            Action:
              - ssm:DescribeAssociation
              - ssm:GetDeployablePatchSnapshotForInstance
              - ssm:GetDocument
              - ssm:DescribeDocument
              - ssm:GetManifest
              - ssm:GetParameters
              - ssm:ListAssociations
              - ssm:ListInstanceAssociations
              - ssm:PutInventory
              - ssm:PutComplianceItems
              - ssm:PutConfigurePackageResult
              - ssm:UpdateAssociationStatus
              - ssm:UpdateInstanceAssociationStatus
              - ssm:UpdateInstanceInformation
            Resource: "*"
          - Effect: Allow
            Action:
              - ssmmessages:CreateControlChannel
              - ssmmessages:CreateDataChannel
              - ssmmessages:OpenControlChannel
              - ssmmessages:OpenDataChannel
            Resource: "*"
          - Effect: Allow
            Action:
              - ec2messages:AcknowledgeMessage
              - ec2messages:DeleteMessage
              - ec2messages:FailMessage
              - ec2messages:GetEndpoint
              - ec2messages:GetMessages
              - ec2messages:SendReply
            Resource: "*"
          - Effect: Allow
            Action: 
              - route53:ChangeResourceRecordSets
            Resource: !Sub "arn:aws:route53:::hostedzone/${InternalZoneInfo.Id}"
          - Effect: Allow
            Action: 
              - route53:ListHostedZones
              - route53:GetChange
            Resource: "*"
          - Effect: Allow
            Action:
              - iam:GetUser
              - iam:ListAccessKeys
            Resource: !GetAtt SendEmailUser.Arn
          - Effect: Allow
            Action: s3:GetObject
            Resource: !Sub "${BoxKeysBucket.Arn}/*"
          - Effect: Allow
            Action:
              - s3:ListBucket
            Resource:
              - !Sub '${BoxKeysBucket.Arn}'
          - Effect: Allow
            Action:
              - s3:GetObject
              - s3:DeleteObject
              - s3:PutObject
              - s3:PutObjectAcl
            Resource:
              - !Sub '${AssetsBucket.Arn}/hubs/*'
              - !Sub '${AssetsBucket.Arn}/spoke/*'
          - Effect: Allow
            Action:
              - s3:GetObject
              - s3:PutObject
              - s3:PutObjectAcl
            Resource:
              - !Sub '${LambdaBucket.Arn}/*'
          - Effect: Allow
            Action:
              - s3:ListBucket
            Resource:
              - !Sub '${AssetsBucket.Arn}'
          - Effect: Allow
            Action: cloudformation:DescribeStacks
            Resource: !Ref "AWS::StackId"
          - Effect: Allow
            Action:
              - ssm:PutParameter
              - ssm:DeleteParameter
              - ssm:GetParameterHistory
              - ssm:GetParametersByPath
              - ssm:GetParameters
              - ssm:GetParameter
              - ssm:DeleteParameters
            Resource:
              - !Sub "arn:aws:ssm:${AWS::Region}:${AWS::AccountId}:parameter/ita/${AWS::StackName}/*"
              - !Sub "arn:aws:ssm:${AWS::Region}:${AWS::AccountId}:parameter/keymaster/${AWS::StackName}/*"
              - !Sub "arn:aws:ssm:${AWS::Region}:${AWS::AccountId}:parameter/keymaster/${AWS::StackName}"
          - Effect: Allow
            Action:
              - ses:GetSendQuota
            Resource: "*"
          - Effect: Allow
            Action:
              - lambda:ListFunctions
              - lambda:ListTags
            Resource: "*"
          - Effect: Allow
            Action:
              - lambda:UpdateFunctionCode
            Resource:
              - !GetAtt SpeelycaptorInitLambdaFunction.Arn
              - !GetAtt SpeelycaptorConvertLambdaFunction.Arn
              - !GetAtt NearsparkThumbnailLambdaFunction.Arn
              - !GetAtt PhotomnemonicScreenshotLambdaFunction.Arn

  AppALB:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Condition: HasALB
    Properties:
      Name: !Sub "${AWS::StackName}-app"
      SecurityGroups:
        - !Ref AppALBSecurityGroup
      Subnets:
        - !Ref SubnetAPublic
        - !Ref SubnetBPublic
    # Add some slower items here, so domain doesn't come up too early
    DependsOn:
      - AppCloudfrontDistribution
      - AppAssetsCloudfrontDistribution
      - NearsparkCloudfrontDistribution
      - LinkRedirectorCloudfrontDistribution

  AppALBDNSInternal:
    Type: AWS::Route53::RecordSet
    Condition: HasALB
    Properties:
      Name: !Sub "${AWS::StackName}-app-alb.${InternalZoneInfo.Name}"
      HostedZoneId: !Ref InternalZone
      Type: A
      AliasTarget:
        DNSName: !GetAtt AppALB.DNSName
        HostedZoneId: !GetAtt AppALB.CanonicalHostedZoneID

  AppALBRetTargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Condition: HasALB
    Properties:
      Name: !Sub "${AWS::StackName}-ret"
      VpcId: !Ref VPC
      Port: !FindInMap [ServicesMeta, RetInternal, Port]
      Protocol: HTTPS
      TargetGroupAttributes:
      - Key: deregistration_delay.timeout_seconds
        Value: 0
      HealthCheckPath: "/health"
      HealthCheckProtocol: HTTPS
      HealthyThresholdCount: 2
      UnhealthyThresholdCount: 2
      HealthCheckIntervalSeconds: 10
      HealthCheckTimeoutSeconds: 5

  AppALBRetSSLListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Condition: HasALB
    Properties:
      LoadBalancerArn: !Ref AppALB
      Port: 443
      Protocol: HTTPS
      SslPolicy: ELBSecurityPolicy-2015-05
      Certificates:
        - CertificateArn: !If [HasManagedDomain, !Ref ExternalZoneSSLCert, !Ref UnmanagedDomainCertArn]
      DefaultActions:
        - TargetGroupArn: !If [PerformOfflineRedirect, !Ref "AWS::NoValue", !Ref AppALBRetTargetGroup]
          Type: !If [PerformOfflineRedirect, redirect, forward]
          RedirectConfig: !If
            - PerformOfflineRedirect
            - Protocol: !GetAtt ParsedOfflineRedirectUrl.ALBProtocol
              Port: 443
              Host: !GetAtt ParsedOfflineRedirectUrl.ALBHost
              Path: !GetAtt ParsedOfflineRedirectUrl.ALBPath
              Query: !GetAtt ParsedOfflineRedirectUrl.ALBQuery
              StatusCode: "HTTP_307"
            - !Ref "AWS::NoValue"

  AppALBRetSSLListenerInternalCert:
    Type: AWS::ElasticLoadBalancingV2::ListenerCertificate
    Condition: HasALB
    Properties:
      ListenerArn: !Ref AppALBRetSSLListener
      Certificates:
        - CertificateArn: !Ref InternalZoneSSLCert

  AppALBRetClearListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Condition: HasALB
    Properties:
      LoadBalancerArn: !Ref AppALB
      Port: 80
      Protocol: HTTP
      DefaultActions:
        - Type: redirect
          RedirectConfig:
            Port: "443"
            Protocol: HTTPS
            StatusCode: HTTP_301

  AppALBRetListenerRule:
    Type: AWS::ElasticLoadBalancingV2::ListenerRule
    Condition: HasALB
    Properties:
      ListenerArn: !Ref AppALBRetSSLListener
      Priority: 1
      Actions:
        - Type: forward
          TargetGroupArn: !Ref AppALBRetTargetGroup
      Conditions:
        - Field: path-pattern
          Values: ["/"]

  AppInstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      InstanceProfileName: !Sub "${AWS::StackName}-app"
      Roles:
        - !Ref AppRole

  StreamInstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      InstanceProfileName: !Sub "${AWS::StackName}-stream"
      Roles:
        - !Ref StreamRole

  DomainDNS:
    Type: AWS::Route53::RecordSet
    Condition: HasManagedDomain
    Properties:
      Name: !Ref DomainName
      HostedZoneId: !GetAtt ExternalZoneInfo.Id
      Type: A
      AliasTarget:
        DNSName: !If [ HasALB, !GetAtt AppALB.DNSName, !GetAtt AppCloudfrontDistribution.DomainName ]
        HostedZoneId: !If [ HasALB, !GetAtt AppALB.CanonicalHostedZoneID, Z2FDTNDATAQYW2 ]

  ParsedOfflineRedirectUrl:
    Type: Custom::ParsedURL
    Properties:
      URL: !Ref StackOfflineRedirectUrl
      ServiceToken: !GetAtt ParseURL.Arn

  AppCloudfrontDistribution:
    Type: AWS::CloudFront::Distribution
    Properties:
      DistributionConfig:
        Enabled: true
        Origins:
          - Id: !Sub "${AWS::StackName}-app"
            DomainName: !If [ RequestedALB, !Sub "${AWS::StackName}-app-alb.${InternalZoneInfo.Name}", !Sub "${AWS::StackName}-app.${InternalZoneInfo.Name}"]
            CustomOriginConfig:
              HTTPPort: 80
              HTTPSPort: 443
              OriginProtocolPolicy: https-only
              OriginSSLProtocols: [ "SSLv3", "TLSv1", "TLSv1.1", "TLSv1.2" ]
          - Id: !Sub "${AWS::StackName}-redirector"
            DomainName: !Select [2, !Split ["/", !GetAtt RootRedirectorBucket.WebsiteURL]]
            CustomOriginConfig:
              HTTPPort: 80
              HTTPSPort: 443
              OriginProtocolPolicy: http-only
              OriginSSLProtocols: [ "SSLv3", "TLSv1", "TLSv1.1", "TLSv1.2" ]
        Restrictions:
          GeoRestriction:
            RestrictionType: none
            Locations: []
        Aliases:
          - !Ref DomainName
          - !Sub '${AWS::StackName}-cors-proxy.${InternalZoneInfo.Name}'
        HttpVersion: http2
        PriceClass: PriceClass_All
        CustomErrorResponses:
          - ErrorCode: 403
            ErrorCachingMinTTL: 0
          - ErrorCode: 404
            ErrorCachingMinTTL: 0
          - ErrorCode: 500
            ErrorCachingMinTTL: 0
          - ErrorCode: 502
            ErrorCachingMinTTL: 0
          - ErrorCode: 503
            ErrorCachingMinTTL: 0
          - ErrorCode: 504
            ErrorCachingMinTTL: 0
        DefaultCacheBehavior:
          Compress: true
          AllowedMethods:
            - GET
            - HEAD
            - POST
            - PATCH
            - PUT
            - DELETE
            - OPTIONS
          CachedMethods:
            - GET
            - HEAD
          TargetOriginId: !If [ PerformOfflineRedirect, !Sub "${AWS::StackName}-redirector", !Sub "${AWS::StackName}-app"]
          ForwardedValues:
            QueryString: !If [ PerformOfflineRedirect, false, true ]
            Headers: !If [ PerformOfflineRedirect, [], ["Origin", "Content-Type", "Range", "Host", "Authorization", "Access-Control-Request-Method", "Access-Control-Request-Headers"]]
            Cookies:
              Forward: none
          ViewerProtocolPolicy: https-only
          MinTTL: 0
          DefaultTTL: 3600
          MaxTTL: 3600
        ViewerCertificate:
          AcmCertificateArn: !If [HasManagedDomain, !Ref ExternalZoneSSLCertEast, !Ref UnmanagedDomainCertArn]
          SslSupportMethod: sni-only
          MinimumProtocolVersion: TLSv1

  AppAssetsCloudfrontDistribution:
    Type: AWS::CloudFront::Distribution
    Properties:
      DistributionConfig:
        Enabled: true
        Origins:
          - Id: !Sub "${AWS::StackName}-app-assets"
            DomainName: !GetAtt AssetsBucket.RegionalDomainName
            S3OriginConfig:
              OriginAccessIdentity: ""
          - Id: !Sub "${AWS::StackName}-app"
            DomainName: !Sub '${AWS::StackName}-app.${InternalZoneInfo.Name}'
            CustomOriginConfig:
              HTTPPort: 80
              HTTPSPort: 443
              OriginProtocolPolicy: https-only
              OriginSSLProtocols: [ "SSLv3", "TLSv1", "TLSv1.1", "TLSv1.2" ]
        Restrictions:
          GeoRestriction:
            RestrictionType: none
            Locations: []
        Aliases:
          - !Sub '${AWS::StackName}-assets.${InternalZoneInfo.Name}'
        HttpVersion: http2
        PriceClass: PriceClass_All
        CustomErrorResponses:
          - ErrorCode: 403
            ErrorCachingMinTTL: 0
          - ErrorCode: 404
            ErrorCachingMinTTL: 0
          - ErrorCode: 500
            ErrorCachingMinTTL: 0
          - ErrorCode: 502
            ErrorCachingMinTTL: 0
          - ErrorCode: 503
            ErrorCachingMinTTL: 0
          - ErrorCode: 504
            ErrorCachingMinTTL: 0
        CacheBehaviors:
          - PathPattern: "/files/*"
            Compress: true
            AllowedMethods:
              - GET
              - HEAD
              - OPTIONS
            CachedMethods:
              - GET
              - HEAD
            TargetOriginId: !Sub "${AWS::StackName}-app"
            ForwardedValues:
              QueryString: true
              Headers: ["Origin", "Content-Type", "Authorization", "Access-Control-Request-Method", "Access-Control-Request-Headers"]
              Cookies:
                Forward: none
            ViewerProtocolPolicy: https-only
            MinTTL: 0
            DefaultTTL: 3600
            MaxTTL: 3600
        DefaultCacheBehavior:
          Compress: true
          AllowedMethods:
            - GET
            - HEAD
            - OPTIONS
          CachedMethods:
            - GET
            - HEAD
          TargetOriginId: !Sub "${AWS::StackName}-app-assets"
          ForwardedValues:
            QueryString: true
            Headers: ["Origin", "Content-Type", "Access-Control-Request-Method", "Access-Control-Request-Headers"]
            Cookies:
              Forward: none
          ViewerProtocolPolicy: https-only
          MinTTL: 0
          DefaultTTL: 3600
          MaxTTL: 3600
        ViewerCertificate:
          AcmCertificateArn: !Ref InternalZoneSSLCertEast
          SslSupportMethod: sni-only
          MinimumProtocolVersion: TLSv1

  AppAssetsDNS:
    Type: AWS::Route53::RecordSet
    Properties:
      Name: !Sub "${AWS::StackName}-assets.${InternalZoneInfo.Name}"
      HostedZoneId: !Ref InternalZone
      Type: A
      AliasTarget:
        DNSName:
          Fn::GetAtt: [ AppAssetsCloudfrontDistribution, DomainName ]
        HostedZoneId: Z2FDTNDATAQYW2

  StreamSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupName: !Sub "${AWS::StackName}-stream"
      GroupDescription: Stream
      VpcId: !Ref VPC
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: !FindInMap [ServicesMeta, JanusExternal, Port]
          ToPort: !FindInMap [ServicesMeta, JanusExternal, Port]
          CidrIp: 0.0.0.0/0
        - IpProtocol: udp
          FromPort: !FindInMap [ServicesMeta, JanusWebRTCFrom, Port]
          ToPort: !FindInMap [ServicesMeta, JanusWebRTCTo, Port]
          CidrIp: 0.0.0.0/0
        - IpProtocol: tcp
          FromPort: !FindInMap [ServicesMeta, JanusWebRTCFrom, Port]
          ToPort: !FindInMap [ServicesMeta, JanusWebRTCTo, Port]
          CidrIp: 0.0.0.0/0
        - IpProtocol: tcp
          FromPort: !FindInMap [ServicesMeta, Ssh, Port]
          ToPort: !FindInMap [ServicesMeta, Ssh, Port]
          CidrIp: 0.0.0.0/0
      SecurityGroupEgress:
        # Outbound HTTP
        - IpProtocol: tcp
          FromPort: 80
          ToPort: 80
          CidrIp: 0.0.0.0/0
        # Outbound HTTPS
        - IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          CidrIp: 0.0.0.0/0
        # Outbound NTP
        - IpProtocol: tcp
          FromPort: 123
          ToPort: 123
          CidrIp: 0.0.0.0/0
        # Outbound RTP
        - IpProtocol: udp
          FromPort: 0
          ToPort: 65535
          CidrIp: 0.0.0.0/0
        # Outbound DNS
        - IpProtocol: tcp
          FromPort: 53
          ToPort: 53
          CidrIp: 0.0.0.0/0

  StreamJanusAdminAppIngress:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      GroupId: !Ref StreamSecurityGroup
      IpProtocol: tcp
      FromPort: !FindInMap [ServicesMeta, JanusAdmin, Port]
      ToPort: !FindInMap [ServicesMeta, JanusAdmin, Port]
      SourceSecurityGroupId: !Ref AppSecurityGroup

  StreamFullSelfEgress:
    Type: AWS::EC2::SecurityGroupEgress
    Properties:
      GroupId: !Ref StreamSecurityGroup
      IpProtocol: tcp
      FromPort: 0
      ToPort: 65535
      DestinationSecurityGroupId: !Ref StreamSecurityGroup

  CorsProxyDNS:
    Type: AWS::Route53::RecordSet
    Properties:
      Name: !Sub '${AWS::StackName}-cors-proxy.${InternalZoneInfo.Name}'
      HostedZoneId: !Ref InternalZone
      Type: A
      AliasTarget:
        DNSName:
          Fn::GetAtt: [ AppCloudfrontDistribution, DomainName ]
        HostedZoneId: Z2FDTNDATAQYW2

  AppLaunchConfiguration:
    Type: AWS::AutoScaling::LaunchConfiguration
    Properties:
      AssociatePublicIpAddress: true
      BlockDeviceMappings:
        - DeviceName: /dev/sda1
          Ebs:
            VolumeSize: 8
      IamInstanceProfile: !Ref AppInstanceProfile
      InstanceType: !Ref AppInstanceType
      SecurityGroups:
        - !Ref AppSecurityGroup
        - !Ref BioRingSecurityGroup
        - !Ref StorageConnectSecurityGroup
      ImageId: !FindInMap [Regions, !Ref "AWS::Region", ImageId]
      KeyName: !Ref KeyPair
      UserData:
        Fn::Base64: |
          #!/usr/bin/env bash
          /usr/bin/polycosm_boot.sh

  AppPlacementGroup:
    Type: AWS::EC2::PlacementGroup
    Properties:
      Strategy: !If [AppIsNoPlacement, cluster, !If [ AppIsClusterPlacement, !FindInMap [ InstanceTypeMeta, !Ref AppInstanceType, PlacementForCluster ], !Ref AppPlacementGroupStrategy ] ]

  StackTopic:
    Type: AWS::SNS::Topic
    Properties:
      TopicName: !Sub "${AWS::StackName}-topic"
      DisplayName: Topic for handling scaling events and budget triggers
      Subscription:
        - Protocol: lambda
          Endpoint: !GetAtt StackTopicHandler.Arn
      Tags:
        - Key: stack-name
          Value: !Sub "${AWS::StackName}"
        - Key: stack-region
          Value: !Sub "${AWS::Region}"

  AppASG:
    Type: AWS::AutoScaling::AutoScalingGroup
    UpdatePolicy:
      AutoScalingRollingUpdate:
        MaxBatchSize: 10
        PauseTime: PT20M
        SuspendProcesses:
          - HealthCheck
          - ReplaceUnhealthy
          - AZRebalance
          - AlarmNotification
          - ScheduledActions
        MinInstancesInService: !If [IsOffline, 0, !Ref AppInstanceCount]
        WaitOnResourceSignals: true
    Properties:
      AutoScalingGroupName: !Sub "${AWS::StackName}-app"
      AvailabilityZones: !If [AppIsClusterPlacement, [!GetAtt SubnetAPublic.AvailabilityZone], [!GetAtt SubnetAPublic.AvailabilityZone, !GetAtt SubnetBPublic.AvailabilityZone]]
      VPCZoneIdentifier: !If [AppIsClusterPlacement, [!Ref SubnetAPublic], [!Ref SubnetAPublic, !Ref SubnetBPublic]]
      TargetGroupARNs: !If [ HasALB, [ !Ref AppALBRetTargetGroup ], !Ref "AWS::NoValue" ]
      MinSize: 0
      MaxSize: 64
      NotificationConfigurations:
        - NotificationTypes:
          - autoscaling:EC2_INSTANCE_LAUNCH
          - autoscaling:EC2_INSTANCE_TERMINATE
          TopicARN: !Ref StackTopic
      DesiredCapacity: !If [IsOffline, 0, !Ref AppInstanceCount]
      PlacementGroup: !If [AppIsNoPlacement, !Ref "AWS::NoValue", !Ref AppPlacementGroup]
      LaunchConfigurationName: !Ref AppLaunchConfiguration
      Tags:
      - Key: polycosm-roles
        Value: !If [HasStreamingServers, "app", "app,stream"]
        PropagateAtLaunch: true
      - Key: polycosm-type
        Value: "app"
        PropagateAtLaunch: true
      - Key: polycosm-channel
        Value: !If [IsStableChannel, "stable", "unstable"]
        PropagateAtLaunch: true
      - Key: polycosm-window
        Value: !If [ IsWindowA, "a", "b" ]
        PropagateAtLaunch: true
      - Key: bio-ring
        Value: !Sub "${AWS::StackName}"
        PropagateAtLaunch: true
    DependsOn:
      - SshTOTP
      - JWTKeys
      - VapidKeys
      - BioRingKey
      - BioReticulumServiceKey
      - BioJanusServiceKey
      - BioYTDLServiceKey
      - BioPostgrestServiceKey

  StreamLaunchConfiguration:
    Type: AWS::AutoScaling::LaunchConfiguration
    Properties:
      AssociatePublicIpAddress: true
      BlockDeviceMappings:
        - DeviceName: /dev/sda1
          Ebs:
            VolumeSize: 8
      IamInstanceProfile: !Ref StreamInstanceProfile
      InstanceType: !Ref StreamInstanceType
      SecurityGroups:
        - !Ref StreamSecurityGroup
        - !Ref BioRingSecurityGroup
        - !Ref StorageConnectSecurityGroup
      ImageId: !FindInMap [Regions, !Ref "AWS::Region", ImageId]
      KeyName: !Ref KeyPair
      UserData:
        Fn::Base64: |
          #!/usr/bin/env bash
          /usr/bin/polycosm_boot.sh

  StreamASG:
    Type: AWS::AutoScaling::AutoScalingGroup
    UpdatePolicy:
      AutoScalingRollingUpdate:
        MaxBatchSize: 10
        PauseTime: PT20M
        SuspendProcesses:
          - HealthCheck
          - ReplaceUnhealthy
          - AZRebalance
          - AlarmNotification
          - ScheduledActions
        MinInstancesInService: !If [IsOffline, 0, !Ref StreamInstanceCount]
        WaitOnResourceSignals: true
    Properties:
      AutoScalingGroupName: !Sub "${AWS::StackName}-stream"
      AvailabilityZones: [!GetAtt SubnetAPublic.AvailabilityZone, !GetAtt SubnetBPublic.AvailabilityZone]
      VPCZoneIdentifier: [!Ref SubnetAPublic, !Ref SubnetBPublic]
      MinSize: 0
      MaxSize: 64
      DesiredCapacity: !If [IsOffline, 0, !Ref StreamInstanceCount]
      LaunchConfigurationName: !Ref StreamLaunchConfiguration
      Tags:
      - Key: polycosm-roles
        Value: stream
        PropagateAtLaunch: true
      - Key: polycosm-type
        Value: stream
        PropagateAtLaunch: true
      - Key: polycosm-channel
        Value: !If [IsStableChannel, "stable", "unstable"]
        PropagateAtLaunch: true
      - Key: polycosm-window
        Value: !If [ IsWindowA, "a", "b" ]
        PropagateAtLaunch: true
      - Key: bio-ring
        Value: !Sub "${AWS::StackName}"
        PropagateAtLaunch: true
    DependsOn:
      - SshTOTP
      - JWTKeys
      - VapidKeys
      - BioRingKey
      - BioReticulumServiceKey
      - BioJanusServiceKey
      - BioYTDLServiceKey
      - BioPostgrestServiceKey

  StorageEFS:
    Type: Custom::EFS
    DeletionPolicy: Retain
    Properties:
      PerformanceMode: generalPurpose
      LifecyclePolicies:
        - TransitionToIA: AFTER_30_DAYS
      FileSystemTags:
        - 
          Key: backup
          Value: daily
        - 
          Key: Name
          Value: !Sub "${AWS::StackName}-storage"
      RestoreBackupVaultName: !Ref RestoreBackupVaultName
      RestoreRecoveryPointArn: !Ref RestoreRecoveryPointArn
      RestoreIamRoleArn: !GetAtt DailyBackupRole.Arn
      ServiceToken: !GetAtt EFSCreateOrRestore.Arn

  StorageEFSAppMountTargetAPrivate:
    Type: AWS::EFS::MountTarget
    Properties:
      FileSystemId: !Ref StorageEFS
      SecurityGroups:
        - !Ref StorageSecurityGroup
      SubnetId: !Ref SubnetAPrivate

  StorageEFSAppMountTargetBPrivate:
    Type: AWS::EFS::MountTarget
    Properties:
      FileSystemId: !Ref StorageEFS
      SecurityGroups:
        - !Ref StorageSecurityGroup
      SubnetId: !Ref SubnetBPrivate

  StorageSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupName: !Sub "${AWS::StackName}-storage-fs"
      GroupDescription: Storage EFS
      VpcId: !Ref VPC

  StorageConnectSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupName: !Sub "${AWS::StackName}-storage-fs-connect"
      GroupDescription: Storage EFS Connect
      VpcId: !Ref VPC
      SecurityGroupEgress:
        # Outbound NFS
        - IpProtocol: tcp
          FromPort: 2049
          ToPort: 2049
          DestinationSecurityGroupId: !Ref StorageSecurityGroup

  StorageFSConnectIngress:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      GroupId: !Ref StorageSecurityGroup
      IpProtocol: tcp
      FromPort: 2049
      ToPort: 2049
      SourceSecurityGroupId: !Ref StorageConnectSecurityGroup

  DailyBackupVault:
    Type: AWS::Backup::BackupVault
    DeletionPolicy: Retain
    Properties:
      BackupVaultName: !Join ["-", [ !Sub "${AWS::StackName}-daily-backup", !Select [0, !Split [ "-", !Select [2, !Split ["/", !Ref "AWS::StackId"]]]]]]
      EncryptionKeyArn: !If [CreateDiskEncryptionKey, !GetAtt DiskKmsKey.Arn, !Ref "AWS::NoValue"]

  DailyBackupPlan:
    Type: AWS::Backup::BackupPlan
    Properties:
      BackupPlan:
        BackupPlanName: !Sub "${AWS::StackName}-daily-backup-plan"
        BackupPlanRule:
          -
            RuleName: "Daily"
            TargetBackupVault: !Ref DailyBackupVault
            ScheduleExpression: "cron(0 10 ? * * *)" # 3AM PST
    DependsOn: DailyBackupVault

  DailyBackupRole:
    Type: AWS::IAM::Role
    Properties:
     AssumeRolePolicyDocument:
       Version: "2012-10-17"
       Statement:
         -
          Effect: Allow
          Principal:
            Service:
              - backup.amazonaws.com
          Action:
            - "sts:AssumeRole"
     ManagedPolicyArns:
       -
        "arn:aws:iam::aws:policy/service-role/AWSBackupServiceRolePolicyForBackup"
       -
        "arn:aws:iam::aws:policy/service-role/AWSBackupServiceRolePolicyForRestores"

  DailyBackupSelection:
    Type: AWS::Backup::BackupSelection
    Properties:
      BackupSelection:
        SelectionName: !Sub "${AWS::StackName}-daily-backup-selection"
        IamRoleArn: !GetAtt DailyBackupRole.Arn
        ListOfTags:
         -
           ConditionType: "STRINGEQUALS"
           ConditionKey: backup
           ConditionValue: daily
      BackupPlanId: !Ref DailyBackupPlan
    DependsOn: DailyBackupPlan

  AppDbSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupName: !Sub "${AWS::StackName}-app-db"
      GroupDescription: DB
      VpcId: !Ref VPC
      SecurityGroupIngress:
        - IpProtocol: tcp
          ToPort: !FindInMap [ServicesMeta, PostgreSQL, Port]
          FromPort: !FindInMap [ServicesMeta, PostgreSQL, Port]
          SourceSecurityGroupId: !Ref AppSecurityGroup

  DiskKmsKey:
    Type: AWS::KMS::Key
    Condition: CreateDiskEncryptionKey
    DeletionPolicy: Retain
    Properties:
      Description: DB encryption key
      KeyPolicy:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            AWS: !Sub 'arn:aws:iam::${AWS::AccountId}:root'
          Action: 'kms:*'
          Resource: '*'
        - Effect: Allow
          Principal:
            AWS: '*'
          Action:
          - 'kms:Encrypt'
          - 'kms:Decrypt'
          - 'kms:ReEncrypt*'
          - 'kms:GenerateDataKey*'
          - 'kms:CreateGrant'
          - 'kms:ListGrants'
          - 'kms:DescribeKey'
          Resource: '*'
          Condition:
            StringEquals:
              'kms:CallerAccount': !Ref 'AWS::AccountId'
              'kms:ViaService': !Sub 'rds.${AWS::Region}.amazonaws.com'

  DiskKmsKeyAlias:
    Type: AWS::KMS::Alias
    Condition: CreateDiskEncryptionKey
    DeletionPolicy: Retain
    DependsOn: AppDb
    Properties:
      AliasName: !Join ["-", [ !Sub "alias/db-app-db-${AWS::StackName}", !Select [0, !Split [ "-", !Select [2, !Split ["/", !Ref "AWS::StackId"]]]]]]
      TargetKeyId: !Ref DiskKmsKey

  AppDbSubnet:
    Type: AWS::RDS::DBSubnetGroup
    Properties:
      DBSubnetGroupDescription: app-db
      DBSubnetGroupName: !Sub "${AWS::StackName}-app-db"
      SubnetIds:
        - !Ref SubnetAPrivate
        - !Ref SubnetBPrivate

  RestoreAppDbSecret:
    Type: Custom::ReadSecret
    Condition: IsRestore
    Properties:
      ServiceToken: !GetAtt ReadSecret.Arn
      SecretArn: !Ref RestoreAppDbSecretArn

  AppDbSecret:
    Type: AWS::SecretsManager::Secret
    DeletionPolicy: Retain
    Properties: !If
      - IsRestore
      - Description: !Sub "${AWS::StackName} Database Secret"
        SecretString: !GetAtt RestoreAppDbSecret.SecretString
      - Description: !Sub "${AWS::StackName} Database Secret"
        GenerateSecretString:
          SecretStringTemplate: '{ "username": "postgres" }'
          GenerateStringKey: 'password'
          PasswordLength: 64
          ExcludePunctuation: true

  AppDbSecretAttachment:
    Type: AWS::SecretsManager::SecretTargetAttachment
    Properties:
      SecretId: !Ref AppDbSecret
      TargetId: !Ref AppDb
      TargetType: AWS::RDS::DBCluster

  AppDbSecretResourcePolicy:
    Type: AWS::SecretsManager::ResourcePolicy
    Properties: 
      SecretId: !Ref AppDbSecret
      ResourcePolicy:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              AWS: !GetAtt AppRole.Arn
            Action: secretsmanager:GetSecretValue
            Resource: "*"
          - Effect: "Deny"
            Principal:
              AWS: !Sub "arn:aws:iam::${AWS::AccountId}:root"
            Action: "secretsmanager:DeleteSecret"
            Resource: "*"

  AppPostgrestDbSecret:
    Type: Custom::GenerateSecret
    DeletionPolicy: Retain
    Properties:
      Description: 'PostgREST admin db password'
      ServiceToken: !GetAtt GenerateSecret.Arn
      Name: postgrest-db-secret
      Region: !Ref "AWS::Region"
      StackName: !Ref "AWS::StackName"
      CopyFromStackName: !If [IsRestore, !Ref RestoreStackName, !Ref "AWS::NoValue"]
      CopyFromStackRegion: !If [IsRestore, !Ref RestoreStackRegion, !Ref "AWS::NoValue"]

  AppDb:
    Type: AWS::RDS::DBCluster
    Properties:
      AvailabilityZones:
        - !GetAtt SubnetAPrivate.AvailabilityZone
        - !GetAtt SubnetBPrivate.AvailabilityZone
      BackupRetentionPeriod: !Ref DbBackupRetentionPeriod
      DatabaseName: polycosm_production
      DBClusterIdentifier: !Sub "${AWS::StackName}-app-db"
      DBSubnetGroupName: !Ref AppDbSubnet
      Engine: aurora-postgresql
      EngineMode: serverless
      EngineVersion: 10.7
      KmsKeyId: !If [CreateDiskEncryptionKey, !Ref DiskKmsKey, !Ref "AWS::NoValue"]
      StorageEncrypted: true
      MasterUsername: !If [IsRestore, !Ref "AWS::NoValue", !Join ['', ['{{resolve:secretsmanager:', !Ref AppDbSecret, ':SecretString:username}}' ]]]
      MasterUserPassword: !If [IsRestore, !Ref "AWS::NoValue", !Join ['', ['{{resolve:secretsmanager:', !Ref AppDbSecret, ':SecretString:password}}' ]]]
      ScalingConfiguration:
        AutoPause: !If [EnableDbAutoPause, true, false]
        MaxCapacity: !Ref DbMaxCapacity
        MinCapacity: 2
        SecondsUntilAutoPause: 300
      SnapshotIdentifier: !If [IsRestore, !Ref RestoreDbSnapshotIdentifier, !Ref "AWS::NoValue"]
      VpcSecurityGroupIds:
        - !Ref AppDbSecurityGroup
      Tags:
        - Key: Name
          Value: !Sub "app-db"

  AppDbBudget:
    Type: AWS::Budgets::Budget
    Condition: HasDbMonthlyBudget
    DependsOn: StackTopicHandlerTopicPolicy
    Properties:
      Budget:
        BudgetLimit: 
          Amount: !Ref DatabaseMonthlyBudget
          Unit: USD
        BudgetName: !Sub "${AWS::StackName}-app-db"
        BudgetType: COST
        TimeUnit: MONTHLY
        CostFilters: 
          UsageType: 
            - !Join [ "-", [!FindInMap [Regions, !Ref "AWS::Region", Abbreviation], "Aurora:ServerlessUsage" ]]
      NotificationsWithSubscribers:
        - Notification:
            NotificationType: ACTUAL
            ComparisonOperator: GREATER_THAN
            Threshold: 100
          Subscribers:
           - SubscriptionType: EMAIL
             Address: !Ref AdminEmailAddress
           - SubscriptionType: SNS
             Address: !Ref StackTopic

# Secrets
  JanusAndReticulumAdminSecret:
    Type: Custom::GenerateSecret
    DependsOn: AppPostgrestDbSecret
    Properties:
      Description: 'Janus and Reticulum Admin Secret'
      ServiceToken: !GetAtt GenerateSecret.Arn
      Name: janus-and-reticulum-admin
      Region: !Ref "AWS::Region"
      StackName: !Ref "AWS::StackName"

  PhoenixKeySecret:
    Type: Custom::GenerateSecret
    DeletionPolicy: Retain
    DependsOn: JanusAndReticulumAdminSecret
    Properties:
      Description: 'Phoenix secret base key'
      ServiceToken: !GetAtt GenerateSecret.Arn
      Name: phoenix-key
      Region: !Ref "AWS::Region"
      StackName: !Ref "AWS::StackName"
      CopyFromStackName: !If [IsRestore, !Ref RestoreStackName, !Ref "AWS::NoValue"]
      CopyFromStackRegion: !If [IsRestore, !Ref RestoreStackRegion, !Ref "AWS::NoValue"]

  GuardianSecretKeySecret:
    Type: Custom::GenerateSecret
    DependsOn: PhoenixKeySecret
    Properties:
      Description: 'Reticulum guardian secret key'
      ServiceToken: !GetAtt GenerateSecret.Arn
      Name: guardian-secret-key
      Region: !Ref "AWS::Region"
      StackName: !Ref "AWS::StackName"

  ReticulumOAuthTokenSecret:
    Type: Custom::GenerateSecret
    DependsOn: GuardianSecretKeySecret
    Properties:
      Description: 'Reticulum OAuth Token'
      ServiceToken: !GetAtt GenerateSecret.Arn
      Name: reticulum-oauth-token
      Region: !Ref "AWS::Region"
      StackName: !Ref "AWS::StackName"

  ReticulumCookieSecret:
    Type: Custom::GenerateSecret
    DependsOn: ReticulumOAuthTokenSecret
    Properties:
      Description: 'Reticulum cookie'
      ServiceToken: !GetAtt GenerateSecret.Arn
      Name: reticulum-cookie
      Region: !Ref "AWS::Region"
      StackName: !Ref "AWS::StackName"

  ReticulumBotAccessKeySecret:
    Type: Custom::GenerateSecret
    DependsOn: ReticulumCookieSecret
    Properties:
      Description: 'Reticulum bot access key'
      ServiceToken: !GetAtt GenerateSecret.Arn
      Name: reticulum-bot-access-key
      Region: !Ref "AWS::Region"
      StackName: !Ref "AWS::StackName"

  SendEmailPasswordSecret:
    Type: Custom::GenerateSecret
    DependsOn: ReticulumBotAccessKeySecret
    Properties:
      Description: 'Send email password'
      ServiceToken: !GetAtt GenerateSecret.Arn
      Name: send-email-password
      Region: !Ref "AWS::Region"
      StackName: !Ref "AWS::StackName"
      SecretString: !GetAtt SendEmailPassword.Key

Outputs:
  AddressForRootDomain:
    Description: Serving domain name for your stack. If you did not set up your domain on Route 53, you should add a CNAME DNS record pointing to this domain name to enable Hubs Cloud on your site.
    Value: !If [ HasALB, AppALBDNSInternal, !GetAtt AppCloudfrontDistribution.DomainName ]

  DomainName:
    Description: Primary Hubs Cloud domain name [reticulum/phx/url_host,reticulum/phx/static_url_host,hubs/general/reticulum_server,spoke/general/reticulum_server,spoke/general/hubs_server]
    Value: !Ref DomainName

  CorsOrigins:
    Description: Allowed CORS origins [reticulum/security/cors_origins]
    Value: !Sub "https://${DomainName},https://${ShortlinkZoneInfo.Name}"

  NonCorsProxyDomains:
    Description: Non-CORS proxied domains [hubs/general/non_cors_proxy_domains,spoke/general/non_cors_proxy_domains]
    Value: !Sub "${DomainName},${InternalZoneInfo.Name},${AppAssetsDNS},${AWS::StackName}-${AWS::AccountId}-hubs-worker.com"

  JanusAndReticulumAdminSecret:
    Description: Janus and Reticulum Admin Secret [reticulum/phx/admin_access_key!read-keymaster-secret,janus-gateway/general/admin_secret!read-keymaster-secret,reticulum/janus/admin_secret!read-keymaster-secret]
    Value: janus-and-reticulum-admin

  JanusMediaRtpPortRange:
    Description: Janus WebRTC Port Range [janus-gateway/media/rtp_port_range]
    Value: !Join ["-", [!FindInMap [ServicesMeta, JanusWebRTCFrom, Port], !FindInMap [ServicesMeta, JanusWebRTCTo, Port] ] ]

  JanusNatIceIgnoreList:
    Description: Janus ICE Ignore List [janus-gateway/nat/ice_ignore_list]
    Value: eth0:0

  JanusExternalPort:
    Description: Janus External Port [janus-gateway/transports.websockets/wss_port,reticulum/janus/janus_port]
    Value: !FindInMap [ServicesMeta, JanusExternal, Port]

  JanusAdminPort:
    Description: Janus Admin Port [janus-gateway/transports.http/admin_port,reticulum/janus/admin_port]
    Value: !FindInMap [ServicesMeta, JanusAdmin, Port]

  JanusServiceName:
    Description: Janus Service Name [reticulum/janus/service_name]
    Value: janus-gateway

  RetInternalPort:
    Description: Reticulum Internal Port [reticulum/phx/port]
    Value: !FindInMap [ServicesMeta, RetInternal, Port]

  RetPhoenixSecretKey:
    Description: Reticulum Phoenix Secret Key [reticulum/phx/secret_key!read-keymaster-secret]
    Value: phoenix-key

  RetExternalPort:
    Description: Reticulum URL Port [reticulum/phx/url_port]
    Value: !FindInMap [ServicesMeta, RetExternal, Port]

  CorsProxyDNS:
    Description: CORS Proxy Domain Name [reticulum/phx/cors_proxy_url_host,hubs/general/cors_proxy_server,spoke/general/cors_proxy_server]
    Value: !Ref CorsProxyDNS

  AppDNS:
    Description: Load balanced app DNS [reticulum/phx/secondary_url_host]
    Value: !Sub "${AWS::StackName}-app.${InternalZoneInfo.Name}"

  RetHostnameDNSSuffix:
    Description: Reticulum Hostname DNS Suffix [reticulum/run/hostname_dns_suffix]
    Value: -local

  GuardianSecretKeySecret:
    Description: Guardian Secret Key [reticulum/guardian/secret_key!read-keymaster-secret]
    Value: guardian-secret-key

  ReticulumPermsKey:
    Description: Reticulum Perms Key [reticulum/guardian/perms_key!read-s3-file-escaped]
    Value: !Sub "s3://${BoxKeysBucket}/jwt-key.pem"

  ReticulumVapidKeys:
    Description: Reticulum Vapid Keys [reticulum/web_push/public_key!read-s3-file-as-json(publicKey),reticulum/web_push/private_key!read-s3-file-as-json(privateKey)]
    Value: !Sub "s3://${BoxKeysBucket}/vapid.json"

  ReticulumWebPushSubject:
    Description: Reticulum Web Push Subject [reticulum/web_push/subject]
    Value: !Sub "mailto:info@${SESDomain}"

  ReticulumOAuthTokenSecret:
    Description: Reticulum OAuth Token Secret [reticulum/guardian/oauth_token_key!read-keymaster-secret]
    Value: reticulum-oauth-token

  ReticulumCookieSecret:
    Description: Reticulum Cookie Secret [reticulum/erlang/node_cookie!read-keymaster-secret]
    Value: reticulum-cookie

  ReticulumBotAccessKeySecret:
    Description: Reticulum Bot Access Key Secret [reticulum/ret/bot_access_key!read-keymaster-secret]
    Value: reticulum-bot-access-key

  AppDbUsername:
    Description: App DB Username [reticulum/db/username,ita/db/username]
    Value: postgres

  AppDbSecret:
    Description: App DB Secret [ita/db/password!read-aws-secret]
    Value: !Ref AppDbSecret

  AppPostgrestDbSecret:
    Description: App PostgREST DB Secret [reticulum/db/postgrest_password!read-keymaster-secret]
    Value: postgrest-db-secret

  AppDbDatabase:
    Description: App DB Database [reticulum/db/database,ita/db/database]
    Value: polycosm_production

  AppDbHostname:
    Description: App DB Hostname [ita/db/hostname]
    Value: !GetAtt AppDb.Endpoint.Address

  PostgrestDbURI:
    Description: Postgrest DB URI [postgrest/db/uri!inject-keymaster-secret]
    Value: !Sub "postgres://postgrest_authenticator:{postgrest-db-secret}@${AppDb.Endpoint.Address}/polycosm_production"

  PgbouncerDb:
    Description: Pgbouncer DB Info [pgbouncer/pgbouncer/db!inject-aws-secret]
    Value: !Sub "polycosm_production = host=${AppDb.Endpoint.Address} dbname=polycosm_production user=postgres password={${AppDbSecret}} pool_mode=transaction\npolycosm_locking = host=${AppDb.Endpoint.Address} dbname=polycosm_production user=postgres password={${AppDbSecret}} pool_mode=session"

  AssetsBucket:
    Description: Assets bucket name [hubs/deploy/target,spoke/deploy/target]
    Value: !Ref AssetsBucket

  HubsBaseAssetsPath:
    Description: Base assets path for hubs CDN assets [hubs/general/base_assets_path]
    Value: !Sub 'https://${AppAssetsDNS}/hubs/'

  HubsPageOrigin:
    Description: Hubs page origin [reticulum/pages/hubs_page_origin]
    Value: !Sub 'https://${AssetsBucket.RegionalDomainName}/hubs/pages/latest'

  SpokeBaseAssetsPath:
    Description: Base assets path for spoke CDN assets [spoke/general/base_assets_path]
    Value: !Sub 'https://${AppAssetsDNS}/spoke/'

  SpokePageOrigin:
    Description: Spoke page origin [reticulum/pages/spoke_page_origin]
    Value: !Sub 'https://${AssetsBucket.RegionalDomainName}/spoke/pages/latest'

  AssetsDomain:
    Description: Assets domain for worker
    Value: !GetAtt AssetsBucket.RegionalDomainName

  ClientDeployType:
    Description: Client deploy type [hubs/deploy/type,spoke/deploy/type]
    Value: s3

  NearsparkHost:
    Description: Host of the nearspark service endpoint [hubs/general/thumbnail_server,spoke/general/thumbnail_server]
    Value: !Sub '${NearsparkDNS}'

  SpeelycaptorEndpoint:
    Description: Speelycaptor Service URL [reticulum/speelycaptor/speelycaptor_endpoint]
    Value: !Sub 'https://${SpeelycaptorApiGatewayRestApi}.execute-api.${AWS::Region}.${AWS::URLSuffix}/prod'

  PhotomnemonicEndpoint:
    Description: Photomnemonic Service URL [reticulum/resolver/photomnemonic_endpoint]
    Value: !Sub 'https://${PhotomnemonicApiGatewayRestApi}.execute-api.${AWS::Region}.${AWS::URLSuffix}/prod'

  StorageEFSId:
    Description: Storage EFS volume id
    Value: !Ref StorageEFS

  AppAssetsDNS:
    Description: Storage URL Host [reticulum/uploads/host]
    Value: !Sub "https://${AppAssetsDNS}"

  ReticulumCSP:
    Description: Default Reticulum Content Security Policy [reticulum/security/content_security_policy]
    Value: !Sub "default-src 'none'; manifest-src 'self'; script-src https://${AWS::StackName}-${AWS::AccountId}-hubs-worker.com 'self' 'sha256-hsbRcgUBASABDq7qVGVTpbnWq/ns7B+ToTctZFJXYi8=' 'sha256-MIpWPgYj31kCgSUFc0UwHGQrV87W6N5ozotqfxxQG0w=' 'sha256-/S6PM16MxkmUT7zJN2lkEKFgvXR7yL4Z8PCrRrFu4Q8=' https://www.google-analytics.com https://${AppAssetsDNS} https://aframe.io https://www.youtube.com https://s.ytimg.com 'unsafe-eval'; prefetch-src 'self'https://${AWS::StackName}-${AWS::AccountId}-hubs-worker.com https://${AppAssetsDNS}; child-src 'self' blob:; worker-src https://${AppAssetsDNS} 'self' blob:; font-src 'self' https://fonts.googleapis.com https://cdn.jsdelivr.net https://fonts.gstatic.com https://cdn.aframe.io https://${AppAssetsDNS} https://${AWS::StackName}-${AWS::AccountId}-hubs-worker.com https://${CorsProxyDNS}; style-src 'self' https://fonts.googleapis.com https://cdn.jsdelivr.net https://${AppAssetsDNS} https://${CorsProxyDNS} https://${AWS::StackName}-${AWS::AccountId}-hubs-worker.com 'unsafe-inline'; connect-src 'self' https://${CorsProxyDNS} https://cors-proxy.${AWS::StackName}-${AWS::AccountId}-hubs-worker.com https://${AWS::StackName}-${AWS::AccountId}-hubs-worker.com https://${ShortlinkZoneInfo.Name} https://dpdb.webvr.rocks https://${AppAssetsDNS} https://${CorsProxyDNS} https://${NearsparkDNS} wss://*.${InternalZoneInfo.Name} wss://*.${InternalZoneInfo.Name}:8443 https://cdn.aframe.io https://www.youtube.com https://api.github.com data: blob:; img-src 'self' https://www.google-analytics.com https://${AppAssetsDNS} https://${CorsProxyDNS} https://cors-proxy.${AWS::StackName}-${AWS::AccountId}-hubs-worker.com https://${AWS::StackName}-${AWS::AccountId}-hubs-worker.com https://${NearsparkDNS} https://cdn.aframe.io https://www.youtube.com https://user-images.githubusercontent.com https://cdn.jsdelivr.net data: blob:; media-src 'self' https://${CorsProxyDNS} https://cors-proxy.${AWS::StackName}-${AWS::AccountId}-hubs-worker.com https://${AWS::StackName}-${AWS::AccountId}-hubs-worker.com https://${AppAssetsDNS} https://${NearsparkDNS} https://www.youtube.com *.googlevideo.com data: blob:; frame-src https://www.youtube.com https://docs.google.com 'self'; base-uri 'none'; form-action 'self';"

  SmtpSendAccessKey:
    Description: SMTP send access key for email zone [reticulum/email/username]
    Value: !Ref SendEmailAccessKey

  SmtpSendPassword:
    Description: SMTP send access key for email zone [reticulum/email/password!read-keymaster-secret]
    Value: send-email-password

  SmtpSendFromAddress:
    Description: SMTP send from address [reticulum/email/from]
    Value:
      Fn::If:
        - HasEmailSubdomain
        - !Sub "noreply@${EmailSubdomain}.${SESDomain}"
        - !Sub "noreply@${SESDomain}"

  StmpServer:
    Description: SMTP server [reticulum/email/server]
    Value: email-smtp.us-east-1.amazonaws.com

  SESRegion:
    Description: SES region
    Value: us-east-1

  StmpPort:
    Description: SMTP port [reticulum/email/port]
    Value: 587

  BioCensusPort:
    Description: Bio census HTTP port [reticulum/habitat/http_port]
    Value: !FindInMap [ServicesMeta, BioCensus, Port]

  InternalZoneId:
    Description: Internal Zone Id
    Value: !GetAtt InternalZoneInfo.Id

  InternalZoneDomainName:
    Description: Internal Zone Domain Name
    Value: !GetAtt InternalZoneInfo.Name

  BoxKeysBucketName:
    Description: Box Keys Bucket Name
    Value: !Ref BoxKeysBucket

  BucketRegion:
    Description: Bucket Region [hubs/deploy/region,spoke/deploy/region,polycosm-lambdas/aws/region]
    Value: !Ref "AWS::Region"

  ShortlinkDomainName:
    Description: Shortlink Domain Name
    Value: !GetAtt ShortlinkZoneInfo.Name

  AdminEmailAddress:
    Description: Administrator Email Address [certbot/general/admin_email]
    Value: !Ref AdminEmailAddress

  YTDLURL:
    Description: YT-DL URL [reticulum/resolver/ytdl_host]
    Value: !Sub ["http://localhost:${Port}", { Port: !FindInMap [ServicesMeta, YTDL, Port] }]

  CertBotPlugin:
    Description: Certbot plugin [certbot/general/plugin]
    Value: dns-route53

  StackName:
    Description: Stack name [reticulum/ret/pool,polycosm-lambdas/aws/stack_name]
    Value: !Ref "AWS::StackName"

  LambdaBucketName:
    Description: Lambdas Bucket [polycosm-lambdas/aws/lambda_bucket]
    Value: !Ref LambdaBucket
